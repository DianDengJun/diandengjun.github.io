[{"title":"《数据库原理及应用》考查报告","url":"/2020/12/06/database-course-design/","content":"\n# 需求分析\n\n现要求开发电脑仓库管理系统。电脑仓库管理系统主要针对电脑的库存信息管理，对于仓库日常发生的业务，分为两大类，即入库和出库。经过数据库的设计后，用户通过相应的模块，对仓库进行简单的基本操作，即可轻松管理仓库。\n经过可行性分析和初步的需求调查，确定了系统的功能边界，该系统应能完成下面的功能：\n\n1. 信息登记：在数据库中添加相关电脑、供货商、仓库的信息；\n2. 入库：增加电脑库存并生成入库记录；\n3. 出库：减少电脑库存并生成出库记录。\n\n<!-- more -->\n\n\n# 功能设计\n## 顶层设计\n![](https://img-blog.csdnimg.cn/20201208174320996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n## 第0层设计\n![](https://img-blog.csdnimg.cn/20201208174431387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n## 入库设计\n+ 输入：待入库的电脑名称（型号）、存储该类电脑仓库名称、入库电脑数量\n+ 输出：入库记录\n+ 操作逻辑：\n\t1.\t根据输入信息，检查电脑型号、仓库名称是否存在，若只要有一个不存在，拒绝入库请求；\n\t2.\t查询库存表中是否有记录，如果没有记录，那么认定为新库存信息，向库存中添加这一信息即可；如果有记录，那么将该记录的电脑数量数据项修改为入库后的数量即可。\n\n![](https://img-blog.csdnimg.cn/20201208174516238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n## 出库设计\n+ 输入：待出库的电脑名称（型号）、存储该类电脑仓库名称、出库电脑数量\n+ 输出：出库记录\n+ 操作逻辑：\n\t1.\t根据输入信息，检查电脑型号、仓库名称是否存在，若只要有一个不存在，拒绝出库请求；\n\t2.\t查询库存表中是否有记录，如果没有记录，那么表示该仓库中没有存储这类电脑，拒绝出库请求；如果有记录，检测出库电脑数量是否大于库存数量，如果大于，表示库存不足，拒绝出库请求；如果有记录并且库存充足，那么将该记录的电脑数量数据项修改为出库后的数量即可。\n\n![](https://img-blog.csdnimg.cn/20201208174532483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n# 关系模型\n## E-R图\n![](https://img-blog.csdnimg.cn/20201208174713372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n## 关系模型设计\n| 关系名   | 属性及码                                                     | 其他约束条件                                                 |\n| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| 供应商   | 供应商编号，供应商名称，供应商地址，供应商电话               | 1、 供应商名称不允许为空；2、 供应商电话不允许为空           |\n| 电脑     | 电脑编号，电脑名称，电脑品牌，电脑单价，供货商编号           | 1、 电脑名称不允许为空；2、 电脑单价不允许为空；3、 供货商编号引用供货商中的供应商编号 |\n| 仓库     | 仓库编号，仓库名称，仓库地址，仓库电话                       | 1、 仓库名称不允许为空；2、 仓库电话不允许为空               |\n| 库存     | 库存记录编号，电脑编号，仓库编号，电脑数量                   | 1、 电脑编号引用电脑关系中的电脑编号；2、 仓库编号引用仓库关系中的仓库编号 |\n| 入库记录 | 入库记录编号，请求入库电脑名称，仓库名称，入库数量，入库总金额，操作日期时间，是否为新型号电脑，成功入库否 | 1、 操作日期时间不允许为空；2、 入库否不允许为空             |\n| 出库记录 | 出库记录编号，请求出库电脑名称，仓库名称，出库数量，操作日期时间，是否全部出库，成功出库否 | 1、 操作日期时间不允许为空；2、 成功出库否不允许为空         |\n## 数据库表设计\n### Supplier（供应商表）\n| 字段名           | 字段含义   | 字段类型    | 是否为空 | 列级约束    |\n| ---------------- | ---------- | ----------- | -------- | ----------- |\n| Supplier_ID      | 供应商编号 | varchar(7)  | not null | primary key |\n| Supplier_Name    | 供应商名称 | varchar(30) | not null | unique      |\n| Supplier_Address | 供应商地址 | varchar(50) |          |             |\n| Supplier_Tel     | 供应商电话 | Varchar(11) | not null |             |\n### Computer（电脑表）\n| 字段名              | 字段含义   | 字段类型    | 是否为空 | 列级约束                                      |\n| ------------------- | ---------- | ----------- | -------- | --------------------------------------------- |\n| Computer_ID         | 电脑编号   | varchar(6)  | not null | primary key                                   |\n| Computer_Name       | 电脑名称   | varchar(30) | not null | unique                                        |\n| Computer_Brand      | 电脑品牌   | varchar(10) |          |                                               |\n| Computer_Unit_Price | 电脑单价   | float       | not null |                                               |\n| Supplier_ID         | 供货商编号 | varchar(7)  | not null | foreign key references Supplier (Supplier_ID) |\n### Warehouse（仓库表）\n| 字段名            | 字段含义 | 字段类型    | 是否为空 | 列级约束    |\n| ----------------- | -------- | ----------- | -------- | ----------- |\n| Warehouse_ID      | 仓库编号 | varchar(6)  | not null | primary key |\n| Warehouse_Name    | 仓库名称 | varchar(30) | not null | unique      |\n| Warehouse_Address | 仓库地址 | varchar(50) |          |             |\n| Warehouse_Tel     | 仓库电话 | varchar(11) | not null |             |\n### Stock（库存表）\n| 字段名       | 字段含义     | 字段类型   | 是否为空 | 列级约束                                       |\n| ------------ | ------------ | ---------- | -------- | ---------------------------------------------- |\n| Stock_ID     | 库存记录编号 | varchar(6) | not null |                                                |\n| Computer_ID  | 电脑编号     | varchar(6) | not null | foreign key references Computer(Computer_ID)   |\n| Warehouse_ID | 仓库编号     | varchar(6) | not null | foreign key references Warehouse(Warehouse_ID) |\n| Number       | 电脑总数     | int        | not null |                                                |\n\n表级约束：primary key (Stock_ID, Computer_ID, Warehouse_ID)\n\n### InputRecords（入库记录表）\n| 字段名            | 字段含义         | 字段类型    | 是否为空 | 列级约束    |\n| ----------------- | ---------------- | ----------- | -------- | ----------- |\n| InputRecords_ID   | 入库记录编号     | varchar(8)  | not null | primary key |\n| Computer_Name     | 请求入库电脑名称 | varchar(30) | not null |             |\n| Warehouse_Name    | 仓库名称         | varchar(30) | not null |             |\n| Input_Number      | 入库数量         | int         |          |             |\n| Total_Money       | 入库总金额       | float       |          |             |\n| Input_DateTime    | 操作日期时间     | datetime    | not null |             |\n| isNewTypeComputer | 是否为新型号电脑 | bool        |          |             |\n| isSuccess         | 成功入库否       | bool        | not null |             |\n### OutputRecords（出库记录表）\n| 字段名           | 字段含义         | 字段类型    | 是否为空 | 列级约束    |\n| ---------------- | ---------------- | ----------- | -------- | ----------- |\n| OutputRecords_ID | 出库记录编号     | varchar(8)  | not null | primary key |\n| Computer_Name    | 请求出库电脑名称 | varchar(30) | not null |             |\n| Warehouse_Name   | 仓库名称         | varchar(30) | not null |             |\n| Output_Number    | 出库数量         | int         |          |             |\n| Output_DateTime  | 操作日期时间     | datetime    | not null |             |\n| isAllOutput      | 是否全部出库完   | bool        |          |             |\n| isSuccess        | 成功出库否       | bool        | not null |             |\n# MySQL数据库代码实践\n## 建库、建表\n```sql\n-- 数据库：WarehouseDB\ncreate database WarehouseDB;\nuse WarehouseDB;\n\n-- 表：供应商\ncreate table Supplier\n(\n    Supplier_ID      varchar(7) primary key,      -- 供应商编号\n    Supplier_Name    varchar(30) unique not null, -- 供应商名称\n    Supplier_Address varchar(50),                 -- 供应商地址\n    Supplier_Tel     varchar(11)        not null  -- 供应商电话\n);\n\n-- 表：电脑\ncreate table Computer\n(\n    Computer_ID         varchar(6) primary key,      -- 电脑编号\n    Computer_Name       varchar(30) unique not null, -- 电脑名称\n    Computer_Brand      varchar(10),                 -- 电脑品牌\n    Computer_Unit_Price float              not null, -- 电脑单价\n    Supplier_ID         varchar(7)         not null, -- 供货商编号\n    -- 外码：Computer.Supplier_ID 参考自 Supplier.Supplier_ID\n    foreign key (Supplier_ID) references Supplier (Supplier_ID)\n);\n\n-- 表：仓库\ncreate table Warehouse\n(\n    Warehouse_ID      varchar(6) primary key,      -- 仓库编号\n    Warehouse_Name    varchar(30) unique not null, -- 仓库名称\n    Warehouse_Address varchar(50),                 -- 仓库地址\n    Warehouse_Tel     varchar(11)        not null  -- 仓库电话\n);\n\n-- 表：库存\ncreate table Stock\n(\n    Stock_ID     varchar(6),   -- 库存记录编号\n    Computer_ID  varchar(6),   -- 电脑编号\n    Warehouse_ID varchar(6),   -- 仓库编号\n    Number       int not null, -- 电脑总数\n    -- 主码构成：Stock_ID, Computer_ID, Warehouse_ID\n    primary key (Stock_ID, Computer_ID, Warehouse_ID),\n    -- 外码：Stock.Computer_ID 参考自 Computer.Computer_ID\n    foreign key (Computer_ID) references Computer (Computer_ID),\n    -- 外码：Stock.Warehouse_ID 参考自 Warehouse.Warehouse_ID\n    foreign key (Warehouse_ID) references Warehouse (Warehouse_ID)\n);\n\n-- 表：入库记录\ncreate table InputRecords\n(\n    InputRecords_ID   varchar(8) primary key, -- 入库记录编号\n    Computer_Name     varchar(30) not null,   -- 请求入库电脑名称\n    Warehouse_Name    varchar(30) not null,   -- 仓库名称\n    Input_Number      int,                    -- 入库数量\n    Total_Money       float,                  -- 入库总金额\n    Input_DateTime    datetime    not null,   -- 操作日期时间\n    isNewTypeComputer bool,                   -- 是否为新型号电脑\n    isSuccess         bool        not null    -- 成功入库否\n);\n\n-- 表：出库记录\ncreate Table OutputRecords\n(\n    OutputRecords_ID varchar(8) primary key, -- 出库记录编号\n    Computer_Name    varchar(30) not null,   -- 请求出库电脑名称\n    Warehouse_Name   varchar(30) not null,   -- 仓库名称\n    Output_Number    int,                    -- 出库数量\n    Output_DateTime  datetime    not null,   -- 出库日期时间\n    isAllOutput      bool,                   -- 是否全部出库完\n    isSuccess        bool        not null    -- 成功出库否\n);\n```\n## 编写存储过程\n### 添加供货商\n```sql\n-- 添加供货商\ncreate procedure AddSupplier(in Name varchar(30), in Address varchar(50), in Tel varchar(11))\nbegin\n    declare ID int(5) zerofill;\n    -- 生成ID号\n    select max(cast(substr(Supplier_ID, 3) as signed integer))\n    into ID\n    from Supplier;\n    if ID is null then\n        set ID = 1;\n    else\n        set ID = ID + 1;\n    end if;\n    -- 插入到Supplier表中\n    insert into Supplier\n        value (concat('Su', ID), Name, Address, Tel);\nend;\n```\n### 添加仓库\n\n```sql\n-- 添加仓库\ncreate procedure AddWarehouse(in Name varchar(30), in Address varchar(50), in Tel varchar(11))\nbegin\n    declare ID int(5) zerofill;\n    -- 生成ID号\n    select max(cast(substr(Warehouse_ID, 2) as signed integer))\n    into ID\n    from Warehouse;\n    if ID is null then\n        set ID = 1;\n    else\n        set ID = ID + 1;\n    end if;\n    -- 插入到Supplier表中\n    insert into Warehouse\n        value (concat('W', ID), Name, Address, Tel);\nend;\n```\n### 添加电脑\n\n```sql\n-- 添加电脑\ncreate procedure AddComputer(in Name varchar(30), in Brand varchar(10), in Price float, in SupplierName varchar(30))\nAddProcedure:\nbegin\n    -- 供货商ID\n    declare SupplierID varchar(7);\n    -- 要生成的电脑ID\n    declare ID int(5) zerofill;\n\n    -- 查询对应供货商编号\n    select Supplier_ID\n    into SupplierID\n    from Supplier\n    where Supplier_Name = SupplierName;\n\n    -- 检查供货商是否存在\n    if SupplierID is null then\n        rollback; -- 回滚事务\n        leave AddProcedure;\n    end if;\n\n    -- 生成电脑ID\n    select max(cast(substr(Computer_ID, 2) as signed integer))\n    into ID\n    from Computer;\n    if ID is null then\n        set ID = 1;\n    else\n        set ID = ID + 1;\n    end if;\n\n    -- 插入到Computer表中\n    insert into Computer\n        value (concat('C', ID), Name, Brand, Price, SupplierID);\nend AddProcedure;\n```\n### 入库\n\n```sql\n-- 入库\ncreate procedure Push(in ComputerName varchar(30), in WarehouseName varchar(30), in PushNumber int)\nbegin\n    -- 库存中电脑编号\n    declare ComputerID varchar(6);\n    -- 库存中仓库编号\n    declare WarehouseID varchar(6);\n    -- 要生成的记录ID\n    declare RecordsID int(7) zerofill;\n    -- 当前库存数量\n    declare CurrentNumber int;\n    -- 电脑单价\n    declare UnitPrice float;\n    -- 入库总金额\n    declare TotalMoney float;\n\n    PUSH:\n    begin\n        -- 检查参数\n        CheckOut:\n        begin\n            -- 查询对应电脑编号\n            select Computer_ID\n            into ComputerID\n            from Computer\n            where Computer_Name = ComputerName\n            limit 1;\n\n            -- 查询对应仓库编号\n            select Warehouse_ID\n            into WarehouseID\n            from Warehouse\n            where Warehouse_Name = WarehouseName\n            limit 1;\n\n            -- 检查电脑ID是否已存在\n            if ComputerID is null then\n                set @isSuccess = false; -- 标识请求未成功\n                leave PUSH;\n            end if;\n\n            -- 检查仓库id是否已存在\n            if WarehouseID is null then\n                set @isSuccess = false; -- 标识请求未成功\n                leave PUSH;\n            end if;\n\n            -- 查询当前库存数量\n            select Number\n            INTO CurrentNumber\n            from Stock\n            where Stock.Computer_ID = ComputerID\n              and Stock.Warehouse_ID = WarehouseID;\n\n            -- 查询电脑单价\n            select Computer_Unit_Price\n            into UnitPrice\n            from Computer\n            where Computer_Name = ComputerName;\n\n            -- 计算入库总金额\n            set TotalMoney = UnitPrice * PushNumber;\n        end CheckOut;\n\n        -- 入库\n        PushProcedure:\n        begin\n            set @isSuccess = true; -- 标记请求成功\n            if CurrentNumber is null then\n                -- 新电脑入库\n                begin\n                    -- 要生成的库存号\n                    declare StockID int(5) zerofill;\n                    -- 新电脑入库标记\n                    set @isNew = true;\n                    -- 生成库存号\n                    select max(cast(substr(Stock_ID, 2) as signed integer))\n                    into StockID\n                    from Stock;\n                    if StockID is null then\n                        set StockID = 1;\n                    else\n                        set StockID = StockID + 1;\n                    end if;\n                    -- 库存表更新\n                    insert into Stock\n                        value (concat('S', StockID), ComputerID, WarehouseID, PushNumber);\n                end;\n            else\n                begin\n                    -- 查询该型号电脑的库存ID\n                    select Stock_ID\n                    into @CurrentID\n                    from Stock\n                    where Stock.Computer_ID = ComputerID\n                      and Stock.Warehouse_ID = WarehouseID;\n                    -- 库存表更新\n                    update Stock\n                    set Number = Number + PushNumber\n                    where Stock_ID = @CurrentID;\n                    -- 标记非新电脑入库\n                    set @isNew = false;\n                end;\n            end if;\n        end PushProcedure;\n    end PUSH;\n\n    ReturnInfo:\n    begin\n        -- 生成入库记录ID\n        select max(cast(substr(InputRecords_ID, 2) as signed integer))\n        into RecordsID\n        from InputRecords;\n        if RecordsID is null then\n            set RecordsID = 1;\n        else\n            set RecordsID = RecordsID + 1;\n        end if;\n\n        -- 根据@isSuccess生成相应入库记录\n        if @isSuccess = true then\n            -- 插入到记录表\n            insert into InputRecords\n            values (concat('I', RecordsID), ComputerName,\n                    WarehouseName, PushNumber,\n                    TotalMoney, sysdate(), @isNew, true);\n\n            -- 展示本次请求信息\n            select concat('I', RecordsID)      记录编号,\n                   ComputerName                请求入库电脑,\n                   WarehouseName               仓库,\n                   PushNumber                  入库数量,\n                   TotalMoney                  总金额,\n                   sysdate()                   操作日期时间,\n                   if(@isNew = true, '是', '否') 是否为新型号电脑,\n                   '是'                         是否成功入库;\n        else\n            -- 插入到记录表\n            insert into InputRecords\n            values (concat('I', RecordsID), ComputerName,\n                    WarehouseName, PushNumber, null, sysdate(), null, false);\n\n            -- 展示本次请求信息\n            select concat('I', RecordsID) 记录编号,\n                   ComputerName           请求入库电脑,\n                   WarehouseName          仓库,\n                   PushNumber             入库数量,\n                   sysdate()              操作日期时间,\n                   '否'                    是否成功入库;\n        end if;\n    end ReturnInfo;\n\n    -- 提交事务\n    commit;\nend;\n```\n### 出库\n\n```sql\n-- 出库\ncreate procedure Pop(in ComputerName varchar(30), in WarehouseName varchar(30), in PopNumber int)\nbegin\n    -- 未出库前库存数量\n    declare NumberInStock int;\n    -- 库存中电脑编号\n    declare ComputerID varchar(6);\n    -- 库存中仓库编号\n    declare WarehouseID varchar(6);\n    -- 要生成的记录ID\n    declare RecordsID int(7) zerofill;\n\n    POP:\n    begin\n        -- 查询对应电脑编号\n        select Computer_ID\n        into ComputerID\n        from Computer\n        where Computer_Name = ComputerName\n        limit 1;\n\n        -- 查询对应仓库编号\n        select Warehouse_ID\n        into WarehouseID\n        from Warehouse\n        where Warehouse_Name = WarehouseName\n        limit 1;\n\n        -- 查询库存中的电脑数量\n        select Number\n        into NumberInStock\n        from Stock\n        where Computer_ID = ComputerID\n          and Warehouse_ID = WarehouseID\n        limit 1;\n\n        -- 库存中没有这种型号的电脑\n        if (NumberInStock is null) then\n            set @isSuccess = false; -- 标记请求失败\n            leave POP;\n        end if;\n        -- 库存中电脑数量小于待出库电脑数量\n        if (NumberInStock < PopNumber) then\n            set @isSuccess = false; -- 标记请求失败\n            leave POP;\n        end if;\n        -- 库存中电脑数量等于待出库电脑数量\n        if (NumberInStock = PopNumber) then\n            set @isAllOutput = true; -- 全部出库完\n        end if;\n        -- 库存中电脑数量大于待出库电脑数量\n        if (NumberInStock > PopNumber) then\n            set @isAllOutput = false;\n        end if;\n\n        -- 修改Stock表\n        update Stock\n        set Number = Number - PopNumber\n        where Computer_ID = ComputerID\n          and Warehouse_ID = WarehouseID;\n\n        set @isSuccess = true; -- 标记请求成功\n    end POP;\n\n    -- 生成出库记录ID\n    select max(cast(substr(OutputRecords_ID, 2) as signed integer))\n    into RecordsID\n    from OutputRecords;\n    if RecordsID is null then\n        set RecordsID = 1;\n    else\n        set RecordsID = RecordsID + 1;\n    end if;\n\n    -- 根据@isSuccess生成相应入库记录\n    if @isSuccess = true then\n        -- 生成出库记录\n        insert into OutputRecords\n        values (concat('O', RecordsID), ComputerName,\n                WarehouseName, PopNumber, sysdate(), @isAllOutput, true);\n\n        -- 展示本次请求信息\n        select concat('O', RecordsID)            记录编号,\n               ComputerName                      请求出库电脑,\n               WarehouseName                     仓库,\n               PopNumber                         出库数量,\n               sysdate()                         操作日期时间,\n               if(@isAllOutput = true, '是', '否') 是否全部出库完,\n               '是'                               是否成功出库;\n    else\n        -- 生成出库记录\n        insert into OutputRecords\n        values (concat('O', RecordsID), ComputerName,\n                WarehouseName, PopNumber, sysdate(), null, false);\n\n        -- 展示本次请求信息\n        select concat('O', RecordsID) 记录编号,\n               ComputerName           请求出库电脑,\n               WarehouseName          仓库,\n               PopNumber              出库数量,\n               sysdate()              操作日期时间,\n               '否'                    是否成功出库;\n    end if;\n\n    -- 提交事务\n    commit;\nend;\n```\n### 查询仓库\n\n```sql\n-- 查询仓库\ncreate procedure ShowStock()\nbegin\n    select Stock_ID            编号,\n           Computer_Brand      品牌,\n           Computer_Name       型号,\n           Computer_Unit_Price 单价,\n           Number              数量,\n           Warehouse_Name      仓库地址,\n           Supplier_Name       供货商\n    from Stock,\n         Computer,\n         Warehouse,\n         Supplier\n    where Stock.Computer_ID = Computer.Computer_ID\n      and Stock.Warehouse_ID = Warehouse.Warehouse_ID\n      and Computer.Supplier_ID = Supplier.Supplier_ID;\nend;\n```\n## SQL语句执行\n### 登记相关信息\n```sql\n-- 添加供货商\ncall AddSupplier('供货商一', '供货商一地址', '02710000001');\ncall AddSupplier('供货商二', '供货商二地址', '02710000002');\ncall AddSupplier('供货商三', '供货商三地址', '02710000003');\n-- 添加仓库\ncall AddWarehouse('仓库一', '仓库一地址', '02720000001');\ncall AddWarehouse('仓库二', '仓库二地址', '02720000002');\n-- 添加电脑\ncall AddComputer('Lenovo-Air14', 'Lenovo', 5999, '供货商一');\ncall AddComputer('Lenovo-R7000', 'Lenovo', 6057, '供货商一');\ncall AddComputer('Lenovo-Yoga14', 'Lenovo', 6299, '供货商一');\ncall AddComputer('Lenovo-Pro14', 'Lenovo', 6299, '供货商二');\ncall AddComputer('MiBook-Pro-15.6', 'XiaoMi', 6999, '供货商二');\ncall AddComputer('Dell-G3', 'Dell', 6999, '供货商二');\ncall AddComputer('Dell-XPS13', 'Dell', 8888, '供货商二');\ncall AddComputer('MacBook-Pro-13', 'Apple', 9199, '供货商三');\ncall AddComputer('MacBook-Pro-16', 'Apple', 17399, '供货商三');\ncall AddComputer('Surface-Pro-7', 'Microsoft', 5788, '供货商三');\n```\n### 入库\n```sql\ncall Push('MacBook-Pro-16', '仓库一', 10);\ncall Push('MacBook-Pro-16', '仓库一', 1);\ncall Push('Dell-G3', '仓库一', 100);\ncall Push('Lenovo-Pro14', '仓库二', 45);\ncall Push('Lenovo', '仓库二', 20); -- 这个是拒绝入库的示例\n```\n### 出库\n```sql\ncall Pop('Lenovo-Pro14', '仓库二', 30);\ncall Pop('MacBook-Pro-16', '仓库一', 1);\ncall Pop('Lenovo-Pro14', '仓库二', 15);\ncall Pop('Lenovo-Pro14', '仓库二', 1000); -- 这个是拒绝出库的示例\n```\n## 查询结果展示\n### 查询供货商表\n```sql\nselect Supplier_ID      编号,\n       Supplier_Name    名称,\n       Supplier_Address 地址,\n       Supplier_Tel     电话\nfrom Supplier;\n```\n结果展示：\n![查询供货商表](https://img-blog.csdnimg.cn/20201208215149439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n### 查询仓库表\n\n```sql\nselect Warehouse_ID      编号,\n       Warehouse_Name    名称,\n       Warehouse_Address 地址,\n       Warehouse_Tel     电话\nfrom Warehouse;\n```\n结果展示：\n![](https://img-blog.csdnimg.cn/20201208215404966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n### 查询电脑表\n```sql\nselect Computer_ID         编号,\n       Computer_Name       型号,\n       Computer_Brand      品牌,\n       Computer_Unit_Price 价格,\n       Supplier_Name       供货商\nfrom Computer,\n     Supplier\nwhere Supplier.Supplier_ID = Computer.Supplier_ID\norder by Computer_ID ASC;\n```\n结果展示：\n![](https://img-blog.csdnimg.cn/20201208215539132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n### 查询库存\n```sql\ncall ShowStock;\n```\n结果展示：\n![](https://img-blog.csdnimg.cn/20201208215713696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n### 查询入库记录\n```sql\nselect InputRecords_ID             序号,\n       Computer_Name               请求入库电脑,\n       Warehouse_Name              仓库,\n       Input_Number                出库数量,\n       Input_DateTime              操作时间,\n       case isNewTypeComputer\n           when 1 then '是'\n           when 0 then '否'\n           when null then null\n           end                     是否为新型号电脑,\n       if(isSuccess = 1, '是', '否') 成功入库否\nfrom InputRecords;\n```\n\n结果展示：\n![](https://img-blog.csdnimg.cn/20201208215900680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n### 查询出库记录\n\n```sql\nselect OutputRecords_ID              序号,\n       Computer_Name                 请求出库电脑,\n       Warehouse_Name                仓库,\n       Output_Number                 出库数量,\n       Output_DateTime               操作时间,\n       case isAllOutput\n           when 1 then '是'\n           when 0 then '否'\n           when null then null\n           end                       是否全部出库完,\n       if(isSuccess = 1, '是', '否') 成功出库否\nfrom OutputRecords;\n```\n结果展示：\n![](https://img-blog.csdnimg.cn/20201208220038527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n\n# 总结\n通过本次考查报告，从需求分析、概念结构设计、逻辑结构设计到数据库表实施，掌握了设计数据库的有关步骤。通过前期准备，掌握了数据库的理论、E-R图的构建。\n本次使用了MySQL数据库将理论转换为实践，初步掌握了MySQL建库、建表的语句。并编写了存储过程语句，使得数据库操作简便化。在编写SQL语句时，查阅了许多资料，增强了动手能力。\n本次数据的设计仍有不足，如没有考虑到数据库的多用户操作，应当对每个仓库设立若干管理员，只进行本仓库的管理，细分数据库操作，也符合实际情况，这是数据设计的改进方向。","tags":["课程设计","MySQL"],"categories":["数据库"]},{"title":"《数字逻辑》课程设计报告","url":"/2020/12/02/Course-design-of-digital-logic/","content":"\n# 题目一：数字电子钟设计\n\n## 设计任务及要求\n\n1. 任务\n   用计数器设计一个电子钟，显示时、分、秒。\n2. 要求\n   （1） 小时为 00-23 二十四进制计数器，分、秒为 00-59 六十进制计数器；\n   （2） 用八段数码管进行显示时、分、秒。\n   （3） 用 Logisim 画图，并进行仿真。要求能看到正确的时、分、秒信息。\n   （4） 先用 Logisim 软件仿真测试是否正确，再提交网站（EduCoder）测评。\n\n## 实验条件\n\n1. Java Runtime Environment 环境\n2. Logisim虚拟数字电路仿真平台\n\n## 设计过程\n\n### 设计原理与思路\n\n#### 4位递增计数器的设计\n\n数字电子钟的基本组成单元由4位递增计数器构成，在进行其他器件设计前，先要完成4位递增计数器的设计。\n计数是一种最简单的基本运算。计数器就是实现这种运算的逻辑电路，计数器在数字系统中主要是对脉冲的个数进行计数，以实现测量、计数和控制的功能，同时兼有分频功能。计数器在数字系统中应用广泛，如在电子计算机的控制器中对指令地址进行计数，以便顺序取出下一条指令，等等。\n这里设计了一个带有同步置数、异步清零功能的4位同步递增计数器。\n引脚说明：\n\n| 信号   | 输入输出 | 位宽 | 说明                                            |\n| ------ | -------- | ---- | ----------------------------------------------- |\n| Clock  | 输入     | 1位  | 时钟脉冲，上升沿有效                            |\n| Reset  | 输入     | 1位  | 异步清零端：Reset=1时，Q=0                      |\n| Enable | 输入     | 1位  | 使能端：Reset=0时，Enable=1递增计数、0保持      |\n| Load   | 输入     | 1位  | 同步置数端：Reset=0、Load=1、Clock上升沿时，Q=D |\n| D      | 输入     | 4位  | 并行数据加载端                                  |\n| Q      | 输出     | 4位  | 状态输出端                                      |\n\n具有并行加载功能的计数器原理如下图所示：\n![](https://img-blog.csdnimg.cn/20201229214732581.png)\n将4位递增计数器封装后的外观：\n![](https://img-blog.csdnimg.cn/20201229214751492.png)\n\n#### 六进制计数器的设计\n\n六进制计数器可由4位递增计数器构成，当4位递增计数器计数到6时，异步清零使Q=0，这样就完成了六进制计数器的功能。\n六进制计数器是构成六十进制计数器的基础。\n\n#### 十进制计数器的设计\n\n十进制计数器可由4位递增计数器构成，当4位递增计数器计数到10时，异步清零使Q=0，这样就完成了十进制计数器的功能。\n十进制计数器是构成六十进制计数器的基础。\n\n#### 六十进制计数器的设计\n\n六十进制计数器可由六进制计数器和十进制计数器构成，10进制计数器的进位输出端是六进制计数器的使能端（Enable）触发条件，每十次触发一次6进制计数器，而6进制计数器本身最大计数为6，这样就完成了六十进制计数器的功能。\n六十进制计数器是构成数字电子钟的基础。\n\n#### 24进制计数器的设计\n\n24进制计数器可由两个十进制计数器构成。\n可用第一个十进制表示个位，记为计数器A。第二个十进制计数器表示十位，记为计数器B。\n计数器A的进位输出端是计数器B的使能端（Enable）触发条件，每十次触发一次计数器B，同时，检测计数器A和B的状态输出端，当状态值为23时，使整个电路的进位输出端为1，当状态值为24时，异步清零，使计数器A和B的Q均为0。这样就完成了24进制计数器的功能。\n24进制计数器是构成数字电子钟的基础。\n\n#### 数字电子钟的设计\n\n数字电子钟由小时（0-23）、分钟（0-59）、秒（0-60）构成。\n秒由六十进制计数器构成，计数的条件是时钟的滴答。所以，在实际仿真的时候，可以调整时钟频率为1Hz，使其符合1秒1次的计数规则。\n分钟由六十进制计数器构成，计数的条件是当秒钟产生进位。\n小时由24进制计数器构成，计数的条件是当分钟和秒钟同时产生进位。\n在实际仿真中，用16进制数字显示器件（Hex Digit Display）显示上述器件产生的状态，这样就完成了数字电子钟的功能和设计。\n\n### 逻辑电路图\n\n4位递增计数器：\n![](https://img-blog.csdnimg.cn/20201229215136658.png)\n六进制计数器：\n![](https://img-blog.csdnimg.cn/20201229215215307.png)\n十进制计数器：\n![](https://img-blog.csdnimg.cn/20201229215237491.png)\n六十进制计数器：\n![](https://img-blog.csdnimg.cn/20201229215302132.png)\n24进制计数器：\n![](https://img-blog.csdnimg.cn/20201229215320745.png)\n数字电子钟：\n![](https://img-blog.csdnimg.cn/20201229215414757.png)\n\n## 实验测试\n\n将Clock信号，由手动点击改为时钟连续，将使能端Enable启动，然后进行测试：\n![](https://img-blog.csdnimg.cn/2020122921545320.png)\n\n# 题目二：路灯巡回检测器\n\n## 设计任务及要求\n\n1. 任务\n   用 Verilog 语言设计 8 个路灯巡回检测电路。\n2. 要求\n   1. 巡回检测 8 个路灯，并用 8 个 LED 灯显示好坏。路灯正常时对应的 LED 灯熄灭，路灯故障时对应的 LED 灯点亮；\n   2. 能够迅速、准确地判出哪一个路灯坏，并用一个七段数码管显示出故障 灯的总数；\n   3. 有启动停止开关。\n   4. 自行绑定开发板的管脚，并下载到开发板上观察实际效果。\n\n## 实验条件\n\n1. Verilog编程和EDA设计工具：Altera Quartus Ⅱ 11.0\n2. FPGA开发板：Altera DE2-115\n\n## 设计过程\n\n### 设计原理和思路\n\n使用一个开关作为使能端，控制整个检测器的启动与停止。\n当使能端关闭时，每个路灯无论其是否为故障状态，都不点亮对应的LED灯。同时，七段数码管也不点亮。\n当使能端开启时，设定一个`cnt`作为计数器，使用`always`语句检测每一个路灯是否故障，如果该路灯故障，点亮对应的LED灯，并使`cnt`计数器（每次循环前，`cnt`置零）加`1`；如果该路灯不故障，用七段数码管`hex`显示`cnt`对应的数字。\n\n### Verilog代码\n\n```verilog\nmodule street_lamp_detector(w, hex, leds);\n    input [8:0] w;\n    reg [3:0] cnt;\n    integer k;\n    output reg[0:7] leds;\n    output reg[0:6] hex;\n    always @(w, cnt)\n    begin\n        cnt=0;\n        if(w[8] == 1)\n            begin\n                for(k = 0; k < 8; k = k + 1)\n                    if(w[k] == 1)\n                        begin\n                            leds[k] = 1;\n                            cnt = cnt + 1;\n                        end\n                    else\n                        leds[k] = 0;\n                        case (cnt)\n                            0: hex = 7'b0000001;\n                            1: hex = 7'b1001111;\n                            2: hex = 7'b0010010;\n                            3: hex = 7'b0000110;\n                            4: hex = 7'b1001100;\n                            5: hex = 7'b0100100;\n                            6: hex = 7'b0100000;\n                            7: hex = 7'b0001111;\n                            8: hex = 7'b0000000;\n                            default: hex = 7'b1111111;\n                        endcase\n            end\n        else\n            begin\n                hex = 7'b1111111;\n                leds[0:7] = 0;\n            end\n    end\nendmodule\n```\n\n## 实验测试\n\n### 开发板引脚分配\n\n引脚绑定设置如下：\n![](https://img-blog.csdnimg.cn/20201229220253874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n\n### 联机调试\n\n① 使能端Enable未启动（SW8为0）\n此时，所有器件不工作：\n![](https://img-blog.csdnimg.cn/20201229220425113.png)\n② 使能端Enable启动（SW8为1）\n如下面两图所示，7端数码管HEX0可以根据正确显示：SW0-SW7的对应故障个数：\n![](https://img-blog.csdnimg.cn/20201229220546662.png)\n![](https://img-blog.csdnimg.cn/20201229220602917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n\n# 总结\n\n通过本次课程设计，掌握了有关同步时序电路的知识，了解了同步时序电路的基本设计步骤，并同通过这些知识设计出了基于时序电路的计数器，完成了数字电子钟的仿真设计。\n通过本次课程设计，掌握了Verilog语言的基本特征，学习了`always`、`if`、`case`等语句。结合Altera ED2-115开发版，通过Verilog语言进行编程，最终实现了一个路灯巡回检测器。\n\n","tags":["数字电路","FPGA","课程设计"],"categories":["计算机硬件"]},{"title":"《数据结构》课程设计报告","url":"/2020/11/28/course-design-of-data-structure/","content":"\n课程设计选题：仓库管理系统\n\n# 题目与要求\n## 问题描述\n某电子公司仓库中有若干批次的同一种电脑，按价格、数量来存储。\n要求实现功能:\n1.\t初始化 n 批不同价格电脑入库；\n2.\t出库：销售m台价格为p的电脑；\n3.\t入库：新到m台价格为p的电脑；\n4.\t盘点：电脑的总台数，总金额，最高价，最低价，平均价格。\n\n注：每个数据元素含有价格与数量；同一价格的电脑存储为一个数据元素。\n\n<!-- more -->\n\n## 系统涉及知识点\n仓库管理系统可以使用顺序表、有序表、单链表、有序循环链表等实现，本设计采用有序表实现。\n所谓有序表，是指这样的线性表，其中所有的元素以递增或递减方式有序排列。\n首先要指出的是，有序表是基于顺序表而延伸出来的一种数据结构，其共同点是用一组地址连续的存储单元依次存储线性表的数据元素。\n其次，是有序表的独特之处，它其中的数据元素按照一定的顺序有序排列。\n仓库管理系统适合采用有序表，原因是可以按照商品的价格或数量进行有序排列，方便用户比对价格、数量。\n## 功能要求\n1.\t初始化仓库：初始化n批不同型号的电脑入库；\n2.\t入库：新到m台价格为p的电脑；\n3.\t出库：销售m台价格为p的电脑；\n4.\t盘点仓库：列出仓库的关键数据：电脑的总台数、总金额、最高价、平均价格等；\n\n\t按照有序表的特点以及所使用的编程语言（C++）的特性，本程序还提供了以下功能：\n\n5.\t查询某一型号的电脑的价格、数量；\n6.\t重新对仓库数据按照一定规则排序；\n7.\t导出仓库数据到外部文件；\n8.\t从外部文件导入数据，以初始化仓库。\n\n# 功能设计\n## 数据结构定义\n一、基本数据元素：电脑\n\n```cpp\ntypedef struct computer {\n    char type[50];  // 型号\n    double price;   // 价格\n    int number;     // 数量\n} Computer, ElemType;\n```\n基本数据元素电脑（`Computer`/`ElemType`）采用结构体表示，用于存储某一类电脑的信息：型号（`type[50]`）、价格（`price`）、库存数量（`number`）。\n二、数据结构：有序表\n```cpp\ntypedef struct {\n    ElemType *elem;     // 基地址\n    int length;         // 当前有效数据的个数\n    int listsize;       // 当前存储容量(单位是sizeof(ElemType))\n    bool isInit{false}; // 顺序表是否已经初始化\n    int sortWay{1};     // 顺序表的排序方式\n} SqList;\n```\n数据结构有序表（`SqList`）由以下几个部分组成：\n1.\t数组指针`elem`指示有序表的基地址；\n2.\t`length`指示有序表的当前有效数据个数（长度）；\n3.\t`listsize`指示有序表当前分配的存储空间大小，一旦因插入数据元素（`Computer`）而空间不足时，可进行再分配；\n4.\t`isInit`指示有序表是否已经初始化（即是否有一个确定的基地址）；\n5.\t`sortWay`指示有序表的排序方式，按照值的不同，对应的有序表排序方式也不同。本程序具体设计了以下四种排序方式：1-按照价格升序、2-按照价格降序、3-按照数量升序、4-按照数量降序。\n\n整体的数据结构如下图所示：\n![](https://img-blog.csdnimg.cn/20201230123554943.png)\n## 模块图\n### 入库\n入库有两种方式，一是在仓库中已有和待入库电脑型号相同的数据，此时，检查给出的价格是否与仓库中一致，若一致，同意用户的入库操作。然后只需更改仓库中此种电脑型号的数量。\n示意图如下：\n ![](https://img-blog.csdnimg.cn/20201230123728727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n\n\n第二种方式，入库一种新型号的电脑，则应该按照有序表的排序方式（`sortWay`）在正确位置插入元素。\n示意图如下：\n ![](https://img-blog.csdnimg.cn/20201230123736468.png)\n### 出库\n可以出库的前提是，在仓库中有待出库型号的电脑且仓库中的库存数量大于等于待出库数量。\n第一类情况，待出库电脑的数量在库存中充足（即库存数量大于待出库数量），此时只需更改相应的数据元素。\n示意图如下：\n![](https://img-blog.csdnimg.cn/20201230123845921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n第二类情况，此种型号的电脑恰好全部出库完，则需要删除相应的数据元素。\n示意图如下：\n![](https://img-blog.csdnimg.cn/20201230123857810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n# 功能代码\n## 初始化动态顺序表\n有序表的数据结构是基于顺序表实现的，所以在进行一切操作前，应当初始化一个空的动态顺序表。\n代码如下：\n\n```cpp\nStatus InitSqList(SqList &L, int n) {\n    auto listsize{((n / 10) + 1) * 10}; // 确定顺序表初始内存占用空间\n    L.elem = new ElemType[listsize];    // 分配基地址、顺序表内存\n    if (!L.elem)    // 内存不足\n        return OVERFLOW;\n    L.length = 0;   // 此时顺序表还没有元素，L.length为0\n    L.listsize = listsize;\n    return OK;\n}\n```\n有序表初始分配的内存空间（`listsize`）并没有简单采用一个常数大小（如`10`个`ElemType`字节），这样不用限制用户输入的电脑类型最大个数，对用户友好。具体是通过给定的`n`，计算表达式`((n/10)+1)*10`，使得初始分配的内存为`10`的整数倍大小的`ElemType`字节，比如`n`为`12`，表达式`((n/10)+1)*10`则为`20`。\n需要注意的是，初始化动态顺序表时，还暂无数据元素，`L.length`应为`0`。\n## 创建（初始化）仓库\n创建仓库的前提是，已经初始化过一个空的动态顺序表，这个检测可以在主函数中完成。\n创建有序表式的仓库步骤：\n1.\t输入n个数据元素，存储到顺序表中；\n2.\t对已创建的顺序表按照有序表的排序方式（`L.sortWay`）进行快速排序。\n3.\t更新有序表的相应参数（`length`、`isInit`、`sortWay`）\n代码如下：\n\n```cpp\nvoid CreateWarehouse(SqList &L, int n, int sort_way) {\n    cout << \"请输入这\" << n << \"种电脑各自的型号、单价、总数:(以空格分隔)\" << endl;\n    // 输入n个数据元素\n    for (int i = 0; i < n; i++)\n        cin >> L.elem[i].type >> L.elem[i].price >> L.elem[i].number;\n    // 按照sort_way对刚创建的顺序表排序\n    switch (sort_way) {\n        case 1:\n            // 按价格升序\n            sort(L.elem, L.elem + n, cmp1);\n            break;\n        case 2:\n            // 按价格降序\n            sort(L.elem, L.elem + n, cmp2);\n            break;\n        case 3:\n            // 按数量升序\n            sort(L.elem, L.elem + n, cmp3);\n            break;\n        case 4:\n            // 按数量降序\n            sort(L.elem, L.elem + n, cmp4);\n            break;\n        default:\n            break;\n    }\n    // 更新L的参数\n    L.sortWay = sort_way;\n    L.length = n;\n    L.isInit = true;\n}\n```\n如果使用文件流创建仓库，那么代码略有不同，这部分属于C++的知识。\n不同代码（输入n数据元素）如下：\n```cpp\nstring s;\n// 从文件流输入n个数据元素\nfor (int i = 0; i < n; i++) {\n    ImportFile >> L.elem[i].type >> L.elem[i].price >> L.elem[i].number;\n    getline(ImportFile, s);\n}\n```\n## 显示仓库\n顾名思义，就是将仓库的数据打印出来。\n代码如下：\n\n```cpp\n// 显示仓库\nvoid PrintWarehouse(SqList L) {\n    if (!L.length)\n        cout << \"当前仓库没有数据!\" << endl;\n    else {\n        cout << \"当前仓库数据如下:\" << endl;\n        string sort_way;\n        switch (L.sortWay) {\n            case 1:\n                sort_way = \"(按照价格升序)\";\n                break;\n            case 2:\n                sort_way = \"(按照价格降序)\";\n                break;\n            case 3:\n                sort_way = \"(按照数量升序)\";\n                break;\n            case 4:\n                sort_way = \"(按照数量降序)\";\n                break;\n            default:\n                break;\n        }\n        cout << sort_way << endl;\n        cout << \"-------------------------------------------------------\" << endl;\n        cout << setLeft\n             << setw(5) << \"序号\"\n             << setw(20) << \"型号\"\n             << setw(15) << \"单价\"\n             << setw(15) << \"数量\"\n             << endl;\n        cout << \"-------------------------------------------------------\" << endl;\n        for (int i = 0; i < L.length; i++)\n            cout << setLeft\n                 << setw(5) << i + 1\n                 << setw(20) << L.elem[i].type\n                 << setw(15) << L.elem[i].price\n                 << setw(15) << L.elem[i].number\n                 << endl;\n        cout << \"-------------------------------------------------------\" << endl;\n    }\n}\n```\n## 入库\n入库要考虑两种情况，第一种情况，仓库中已经有和待入库电脑相同型号的数据元素，那么需要先比较价格是否一致（不一致拒绝用户的入库操作），然后更改仓库中此种电脑数据元素的数量值。\n第二种情况入库一种新型号的电脑，那么则要插入一个新的数据元素（`Computer`）到仓库中，并且在插入之前还要检查有序表的内存空间（`listsize`）是否充足，如果不足，则需要再分配有序表的内存大小，即为顺序表增加一个大小为存储`LISTINCREMENT`个数据元素的空间。然后，根据有序表的排序方式（`L.sortWay`），找到可以插入元素的地址。插入时，先将该地址及以后的地址全部后移一位，接着将当前地址写入要入库的数据元素。\n代码如下：\n\n```cpp\nStatus Enter(SqList &L, const Computer &c) {\n    // 寻找仓库中是否已经有和c.type同类型的电脑\n    for (int i = 0; i < L.length; i++) {\n        if (strcmp(c.type, L.elem[i].type) == 0) {\n            if (c.price == L.elem[i].price) {   // 检查价格价格是否与c.price相等\n                L.elem[i].number += c.number;\n                return OK;\n            } else {\n                cout << \"提示:\" << endl;\n                showInfo(L.elem[i]);\n                return ERROR;\n            }\n\n        }\n    }\n\n    // 入库一个新类型的电脑\n    if (L.length >= L.listsize) {   // 顺序表占用空间不足\n        // 申请新的基地址、内存空间\n        auto *newbase = (ElemType *) realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType));\n        if (!newbase)\n            return OVERFLOW;\n        L.elem = newbase;   // L的基地址更改为newbase\n        L.listsize += LISTINCREMENT;\n    }\n    // 按照L.sort_way对插入到顺序表中\n    int item{L.length}; // 确定要插入的位序\n    for (int i = 0; i < L.length; i++) {\n        switch (L.sortWay) {\n            case 1: {\n                if (c.price < L.elem[i].price) {\n                    item = i;\n                    goto change_sq;\n                }\n            }\n                break;\n            case 2: {\n                if (c.price > L.elem[i].price) {\n                    item = i;\n                    goto change_sq;\n                }\n            }\n                break;\n            case 3: {\n                if (c.number < L.elem[i].number) {\n                    item = i;\n                    goto change_sq;\n                }\n            }\n                break;\n            case 4: {\n                if (c.number > L.elem[i].number) {\n                    item = i;\n                    goto change_sq;\n                }\n            }\n                break;\n        }\n    }\n    change_sq:\n    ElemType *q = &L.elem[item];\n    // 将q及q以后的元素全部后移一位\n    for (ElemType *p = L.elem + L.length - 1; p >= q; p--)\n        *(p + 1) = *p;\n    // 将新元素赋给q\n    *q = c;\n    L.length++;\n    return OK;\n}\n```\n要注意的是如果是入库一种新型号的电脑，完成操作后，应当将有序表的长度加1（`L.length++`）。\n## 出库\n出库要考虑以下几种情况：\n1. 仓库中是否有待出库电脑的型号的相应数据元素，如果没有找到相应的电脑型号，则应当拒绝用户的出库操作；\n2. 仓库中现有库存数量是否充足，满足出库要求，如果库存数量小于待出库数量，则应当拒绝用户的出库操作；\n3. 如果库存数量大于待出库数量，那么只需更改相应数据元素的数量值；\n4. 如果库存数量恰好等于待出库数量，那么此时这种型号的电脑应从仓库中“剔除”。具体操作是，找到该数据元素的地址，将该地址及以后的地址全部前移一位。最后，更新L.length参数。\n\n代码如下：\n\n```cpp\nStatus Out(SqList &L, const char *type, int num) {\n    // 确定要出库元素的位序\n    int item{L.length + 1};\n    for (int i = 0; i < L.length; i++) {\n        if (strcmp(type, L.elem[i].type) == 0) {\n            item = i;\n            break;\n        }\n    }\n    // 没有找到要出库元素的位序，说明在仓库中没有元素，返回错误\n    if (item > L.length)\n        return -1;\n\n    // 确定要出库元素现有库存的数量是否可以出库\n    if (num < L.elem[item].number) {\n        // 正常出库\n        L.elem[item].number -= num;\n        return OK;\n    } else if (num == L.elem[item].number) {\n        // 全部出库\n        cout << \"提示:\" << endl\n             << L.elem[item].type << \"型号的电脑已全部出库!\" << endl;\n\n        // 将p及p以后的元素全部后移一位\n        for (ElemType *p = &L.elem[item + 1]; p <= &L.elem[L.length - 1]; p++) {\n            *(p - 1) = *p;\n        }\n        L.length--;\n        return OK;\n    } else {\n        // 库存不足\n        cout << \"提示:\" << endl;\n        showInfo(L.elem[item]);\n        return ERROR;\n    }\n}\n```\n## 查询电脑数据\n查询电脑数据，只需从基地址开始遍历，直到找到数据元素的型号和待查询的型号相同，那么返回电脑信息。\n可以定义一个`item`参数，初始值为`L.length + 1`，如果找到数据元素，则将其更新为数据元素的逻辑位序。如果遍历结束，item都未更新，说明未找到。因为数据元素的最大逻辑位序是有序表的表长（`L.length`），所以判断是否找到数据元素的条件是：`item > L.length`。\n代码如下：\n\n```cpp\nvoid getInfo(SqList L, const char *type) {\n    // 确定要查找的电脑的元素位序\n    int item{L.length + 1};\n    for (int i = 0; i < L.length; i++) {\n        if (strcmp(type, L.elem[i].type) == 0) {\n            item = i;\n            break;\n        }\n    }\n    if (item > L.length)\n        cout << \"没有找到\" << type << \"型号的电脑\" << endl;\n    else {\n        cout << \"信息如下:\" << endl;\n        showInfo(L.elem[item]);\n    }\n}\n```\n## 盘点仓库\n从基地址开始遍历，求得关键数据：总台数（`numSum`）、总金额（`priceSum`）、最高价（`priceMax`）、最低价（`priceMin`）、平均价（`priceAverage`）。\n代码如下：\n\n```cpp\nvoid Check(SqList L) {\n    int numSum{0};\n    double priceSum{0.0}, priceMax{L.elem[0].price}, priceMin{L.elem[0].price}, priceAverage{0.0};\n    vector<char *> priceMaxComputer;    // 存储价格最高的电脑的类型名\n    vector<char *> priceMinComputer;    // 存储价格最低的电脑的类型名\n\n    if (!L.length) {\n        cout << \"当前仓库没有数据!\" << endl;\n    } else {\n        // 求总数、总金额、最高价、最低价\n        for (int i = 0; i < L.length; i++) {\n            numSum += L.elem[i].number;\n            priceSum += L.elem[i].price * L.elem[i].number;\n            priceMax = max(priceMax, L.elem[i].price);\n            priceMin = min(priceMin, L.elem[i].price);\n        }\n        // 记录价格最高、最低的电脑类型名\n        for (int i = 0; i < L.length; i++) {\n            if (L.elem[i].price == priceMax)\n                priceMaxComputer.push_back(L.elem[i].type);\n            if (L.elem[i].price == priceMin)\n                priceMinComputer.push_back(L.elem[i].type);\n        }\n        // 求平均价\n        priceAverage = priceSum / numSum;\n        // 输出信息\n        cout << \"盘点数据如下\" << endl\n             << \"电脑的总台数: \" << numSum << endl\n             << \"电脑的总金额: \" << priceSum << endl\n             << \"电脑的最高价: \" << priceMax << endl\n             << \"           + 对应的型号是: \";\n        for (const auto &c:priceMaxComputer)\n            cout << c << \"\\t\";\n        cout << endl;\n        cout << \"电脑的最低价: \" << priceMin << endl\n             << \"           + 对应的型号是: \";\n        for (const auto &c:priceMinComputer)\n            cout << c << \"\\t\";\n        cout << endl;\n        cout << \"电脑的平均价格: \" << priceAverage << endl;\n    }\n}\n```\n这里定义了两个`char*`向量（`priceMaxComputer`、`priceMinComputer`），用以存储价格最高的电脑的类型名、最低的电脑的类型名，因为可能若干种型号的电脑都是最高价或最低价，所以使用C++的向量数据结构比较合适。这样，可以显示出最高价、最低价相应的电脑类型名，对用户友好。\n## 重新对仓库排序\n只需按照给定的排序方式，对仓库进行快速排序，然后更改`L.sortWay`参数为相应值。\n代码如下：\n\n```cpp\ncout << \"请输入要重新对仓库排序的主要方式\" << endl\n     << \"1. 按价格升序 2. 按价格降序\" << endl\n     << \"3. 按数量升序 4. 按数量降序\" << endl\n     << \"选择1-4:\";\nauto select = input_number(1, 4);\nswitch (select) {\n    case 1:\n        sort(L.elem, L.elem + L.length, cmp1);\n        break;\n    case 2:\n        sort(L.elem, L.elem + L.length, cmp2);\n        break;\n    case 3:\n        sort(L.elem, L.elem + L.length, cmp3);\n        break;\n    case 4:\n        sort(L.elem, L.elem + L.length, cmp4);\n        break;\n    default:\n        break;\n}\nL.sortWay = select;\ncout << \"重新排序成功!\" << endl;\n```\n其中，4种排序方式的代码如下：\n\n```cpp\n// computer排序方式：按价格升序\nbool cmp1(const Computer &a, const Computer &b) {\n    return a.price < b.price;\n}\n\n// computer排序方式：按价格降序\nbool cmp2(const Computer &a, const Computer &b) {\n    return a.price > b.price;\n}\n\n// computer排序方式：按数量升序\nbool cmp3(const Computer &a, const Computer &b) {\n    return a.number < b.number;\n}\n\n// computer排序方式：按数量降序\nbool cmp4(const Computer &a, const Computer &b) {\n    return a.number > b.number;\n}\n```\n## 导出仓库数据到文件\n原理和显示仓库大同小异，只是多了文件流的操作。\n代码如下：\n\n```cpp\nvoid output(SqList L, const string &filename) {\n    // 定义输出文件流filename.txt\n    ofstream OutFile(filename + \".txt\");\n    // 输出文件头，用于下次输入时识别文件\n    OutFile << \"Computer Warehouse Data\" << endl;\n    if (!L.length)\n        OutFile << \"no data\" << endl;\n    else {\n        OutFile << \"The information is as follows:\" << endl;\n        switch (L.sortWay) {\n            case 1:\n                OutFile << \"Sort Way: 1 (Ascending by price)\" << endl;\n                break;\n            case 2:\n                OutFile << \"Sort Way: 2 (Descending by price)\" << endl;\n                break;\n            case 3:\n                OutFile << \"Sort Way: 3 (Ascending by number)\" << endl;\n                break;\n            case 4:\n                OutFile << \"Sort Way: 4 (Descending by number)\" << endl;\n                break;\n            default:\n                break;\n        }\n        OutFile << \"Total Type: \" << L.length << endl;\n\n        // 输出数据信息\n        for (int i = 0; i < L.length; i++)\n            OutFile << L.elem[i].type << \" \"\n                    << L.elem[i].price << \" \"\n                    << L.elem[i].number\n                    << endl;\n        // 关闭文件\n        OutFile.close();\n    }\n}\n```\n# 调试与测试\n**注意：本设计使用的编译器是G++ 8.1.0，在Windows平台上编译、运行成功。\n编译命令为：“g++ main.cpp sqlist.cpp -o main”（不含引号）。**\n## 调试分析\n一、创建仓库\n为方便用户操作，本程序可以导出仓库数据到文件，然后在下次操作时，可以用此文件做仓库的初始化。这是在考虑到程序的友好性后增加的功能。\n无论是手动创建还是从文件导入，方法是大同小异的。\n本模块时间复杂度：$O(nlogn)$（快速排序$O(nlogn)$）\n二、入库、出库、查询、盘点仓库\n时间复杂度均为：$O(n)$\n考虑到程序的友好性，对入库、出库、查询的拒绝操作均给出具体信息。比如，在出库时如果库存数量小于待出库数量，则先显示当前库存，然后提示库存数量不足。\n三、其他\n菜单和主函数设计中，由于经常需要检测输入数字是否在某一范围内，使得生成大量重复代码。于是，将这些代码设计成函数，增加了代码的可读性。并且考虑到，用户的误输入（非数字）会导致程序崩溃，设计了正则表达式匹配，检测用户输入。\n函数代码如下：\n\n```cpp\n// 输入from至end范围内的数字\nint input_number(int from, int end) {\n    auto select{0};\n    string input;\n    regex r(\"[0-9]*\");  // 正则表达式:数字0-9，可以出现多次\n    while (true) {\n        cin >> input;\n        bool isNumber = regex_match(input,r);\n        if (!isNumber)  // 如果input和正则表达式匹配\n            cout << \"输入错误，请输入数字\" << from << \"-\" << end << \":\";\n        else {\n            select = atoi(input.c_str());\n            if (select < from || select > end)\n                cout << \"输入错误，重新输入\" << from << \"-\" << end << \":\";\n            else\n                break;\n        }\n    }\n    return select;\n}\n```\n另外一个是，如果用户在初始化仓库的情况下，进行入库、出库等操作，亦会导致程序崩溃。所以，后来在有序表中增加了一个参数`isInit`，用于指示当前有序表是否已经初始化。在每次操作之前，检测是否已经初始化，这样避免了这一类型的崩溃。\n## 用户手册\n启动本程序后，按照菜单的提示进行操作即可。\n注意：\n1. 第一步必须先初始化仓库，否则，您无法进行其他的操作，将返回“仓库还未初始化!”。\n2. 初始化仓库时，可以选择“2.从外部文件导入”，但前提是，该外部文件要存在，且是以前程序生成的导出合法文件。否则，不存在的文件将提示“没有文件/文件无法打开”，不是合法文件将提示“文件内容不符合要求”，这会导致初始化仓库失败。所以，请检查您输入的文件名和文件内容！\n3. 建议在入库操作之前先显示仓库，确保增加仓库中某一电脑型号的数量时，输入的价格和仓库中一致；\n4. 建议在出库操作之前先显示仓库，确保仓库中有您想要出库的电脑型号，以及其数量充足；\n5. 您可以选择菜单项“7.重新对仓库排序”，按照您喜爱的方式对仓库排序，本程序提供了四种主要排序方式：1-按照价格升序、2-按照价格降序、3-按照数量升序、4-按照数量降序\n6. 建议每次结束程序前，导出仓库数据到文件，这样可以保存仓库数据，方便下次操作。\n## 测试过程\n本设计给出了一个输入文件info.txt\n内容如下：\n```\nComputer Warehouse Data\nThe information is as follows:\nSort Way: 1 (Ascending by price)\nTotal Type: 12\nRedmiBook-14 3299 30\nDell-G5 5699 14\nSurface-Pro-7 5788 20\nLenovo-Air14 5999 17\nLenovo-R7000 6057 12\nLenovo-Yoga14 6299 8\nLenovo-Pro14 6299 10\nMiBook-Pro-15.6 6999 13\nDell-G3 6999 15\nDell-XPS13 8888 5\nMacBook-Pro-13 9199 5\nMacBook-Pro-16 17399 3\n```\n\n下面是各种操作的输出结果（截图）：\n1、菜单显示\n![](https://img-blog.csdnimg.cn/20201230130624751.png)\n2、初始化仓库\n![](https://img-blog.csdnimg.cn/20201230130657360.png)\n3、显示仓库\n![](https://img-blog.csdnimg.cn/20201230130710167.png)\n4、入库\n入库Dell-G5 5699 2：\n![](https://img-blog.csdnimg.cn/20201230130738804.png)\n入库后显示仓库：\n![](https://img-blog.csdnimg.cn/20201230130831651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n入库Huawei-MateBook-X 8999 2：\n![](https://img-blog.csdnimg.cn/20201230130908589.png)\n入库后显示仓库：\n![](https://img-blog.csdnimg.cn/20201230130855122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n5、出库\n出库Huawei-MateBook-X 2:\n![](https://img-blog.csdnimg.cn/20201230130940342.png)\n出库后显示仓库：\n![](https://img-blog.csdnimg.cn/20201230131001590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n6、查询\n查询Lenovo-Pro14\n![](https://img-blog.csdnimg.cn/20201230131032662.png)\n7、盘点仓库\n![](https://img-blog.csdnimg.cn/20201230131107402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n8、重新对仓库排序\n按数量升序对仓库排序：\n![](https://img-blog.csdnimg.cn/20201230131131645.png)\n显示重新排序后的仓库：\n![](https://img-blog.csdnimg.cn/20201230131144395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70)\n# 总结\n通过本次课程设计，在数据结构课程中所学到的顺序表基础上，实现了有序表，并通过基本数据元素（`Computer`）和数据结构（`SqList`）的设计，实现了简易的仓库管理系统。\n在本次课程设计中，也学习到很多的C++的知识，如STL中数据结构与算法的应用（`vector`、`sort`）、文件流（`fstream`）。\n通过设计输入输出文件的功能，解决了以往繁琐的数据输入步骤。同时，也增加了程序的友好性。\n通过输入检测、正则表达式匹配，解决了非法输入导致程序崩溃的问题。\n但限于编程能力，本程序仍存在某些问题，如初始化时，没有对输入相同型号的数据做处理，这是程序的改进方向。\n# 参考文献\n> 严蔚敏，吴伟民.数据结构（C语言版）[M]. 北京：清华大学出版社，1997.\n\n> 严薇敏，吴卫民.数据结构题集（C 语言版）[M].北京：清华大学出版社，1997.\n\n> [美]Y.Danie Liang. C++程序设计.[M].北京：机械工业出版社，2015.\n\n> Michael Wong，IBM XL编译器中国开发团队.深入理解C++11：C++11新特性解析与应用.[M].北京：机械工业出版社，2013.\n# 附录\n源代码见[Github仓库](https://github.com/DianDengJun/Course-Design/tree/main/Data%20Structure)","tags":["课程设计","数据结构","C++"],"categories":["数据结构与算法","线性表"]},{"title":"算法竞赛1 ACM与算法入门","url":"/2020/10/09/Algorithm-Competition-1/","content":"\n\n## 关于ACM\n### 什么是ACM\n\n<center><img src=\"https://bkimg.cdn.bcebos.com/pic/b21bb051f8198618169533f649ed2e738ad4e6f6?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5\" alt=\"ACM LOGO\" height=\"100\"></center>\n\n国际大学生程序设计竞赛（英文全称：ACM International Collegiate Programming Contest），简称ACM或ICPC，是程序设计领域`级别最高`的脑力竞赛，被冠以“程序设计的奥林匹克”。对参赛学生的逻辑分析能力、策略制定和脑力方面具有极大的挑战性，每年全球总冠军将获得“全世界最聪明的人”称号。经过30多年的发展，ACM国际大学生程序设计竞赛已经成为最具影响力的大学生计算机竞赛，在企业招聘以及学术深造都具有`极高的含金量`。\n\n<!-- more -->\n\n### ACM发展史\n\n竞赛的历史可以上溯到1970年，当时在美国德克萨斯A&M大学举办了首届比赛。当时的主办方是the Alpha Chapter of the UPE Computer Science HonorSociety。作为一种全新的发现和培养计算机科学顶尖学生的方式，竞赛很快得到美国和加拿大各大学的积极响应。\n\n1977年，在ACM计算机科学会议期间举办了首次总决赛，并演变成为目前的一年一届的多国参与的国际性比赛。迄今已经举办了37届 。\n\n最初几届比赛的参赛队伍主要来自美国和加拿大，后来逐渐发展成为一项世界范围内的竞赛。\n\n特别是自1997年IBM开始赞助赛事之后，赛事规模增长迅速。1997年，总共有来自560所大学的840支队伍参加比赛。而到了2004年，这一数字迅速增加到840所大学的4109支队伍并以每年10-20%的速度在增长。\n\n1980年，ACM将竞赛的总部设在位于美国德克萨斯州的贝勒大学。\n\n### 竞赛规则\n\n- ACM-ICPC以团队的形式代表各学校参赛，每队由3名队员组成。每位队员必须是在校学生，由一定的年龄限制，并且最多可以参加2次全球总决赛和5次区域选拔赛\n\n- 比赛期间，每队使用1台电脑需要在5个小时内使用C、C++或Java中的一种编程程序解决7到10个问题。程序完成之后提交裁判运行，运行的结果会判定为正确或错误两种并及时通知参赛队。而且有趣的是每队在正确完成一题后，组织者将在其位置上升起一只代表该题颜色的气球。\n\n- 最后的获胜者为正确解答题目最多且总用时最少的队伍\n\n### 比赛特点\n\n+ 与其他计算机程序竞赛（例如国际信息学奥林匹克，IOI）相比，ACM-ICPC的特点在于其题量大，每队需要在5小时内完成10道题目，甚至更多。另外，一支队伍3名队员却只有1台电脑，使得时间显得更为紧张。因此除了扎实的专业水平，良好的团队协作和心理素质同样是获胜的关键。\n\n### 题目特点\n\n> 不要看只有十道题！\n\n+ 题面全英文且包含大量数学公式\n\n+ 涉及大量算法，相互掺杂\n\n+ 测试数据多而刁钻\n\n### 学习ACM之路需要付出什么？\n\n需要学习的算法非常多，需要编写大量的代码，题目覆盖范围太广。在 学习过程中，一个难题或者一个难的知识点可以卡一下午、一整天，想真正掌握一个难的结构、算法， 可能需要好几天。会头脑风暴到怀疑人生。 \n\n### 学习ACM之路能得到什么？\n\n+ 对自身锻炼价值大。ACM涉及到的知识有计算几何，数论、组合数学、图论、动态规划等，几乎包括了计算机专业所有理论知识。\n\n+ 学习算法，拓展思维，提高逻辑分析能力，提高编程能力，当程序出问题时，需要自己去解决问题，在无形中也增加了分析问题和解决问题以及学习的能力。\n\n+ 比赛含金量高。ACM每年举行的亚洲预选赛共有十几个赛区，国内一般有4－5个赛区，决出不到20支队伍参加世界总决赛，并且产生金奖、银奖、铜奖和优胜奖若干。\n\n## 关于算法\n\n中文维基百科：\n\n算法（algorithm），在数学（算学）和计算机科学之中，为任何一系列良定义的具体计算步骤，常用于计算、数据处理和自动推理。作为一个有效方法，算法被用于计算函数，它包含了一系列定义清晰的指令，并可于`有限的时间及空间`内清楚的表述出来。\n\n### 时间复杂度\n\n算法竞赛注重解决问题的效率，我们提出了时间复杂度这一概念来衡量效率。\n\n在计算机科学中，时间复杂性，又称**时间复杂度**，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察**输入值大小趋近无穷**时的情况。\n\n时间复杂度的表示：\n$$\nO(f(n))\n$$\n$n$ 是问题的规模，$f(n)$ 是对应完成问题的时间。\n\n+ 相同大小的不同输入值仍可能造成算法的运行时间不同，因此我们通常使用算法的**最坏情况复杂度**。\n\n+ 一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。多数情况，我们观察最深层循环语句中的操作。\n\n#### 常见的时间复杂度\n\n+ 常数时间 $O(1)$\n\n  复杂度与输入大小无关\n\n  for example:\n\n  ```伪代码\n  int index = 5;\n  int item = list[index];\n  if (condition true) then\n     perform some operation that runs in constant time\n  else\n     perform some other operation that runs in constant time\n  for i = 1 to 100\n     for j = 1 to 200\n        perform some operation that runs in constant time\n  ```\n\n+ 线性时间 $O(n)$\n\n  最深循环 n 次\n\n  for example:\n\n  ```伪代码\n  int n;\n  for i = 1 to n\n  \tdo something here.\n  for j = 1 to n\n      do something here.\n  ```\n\n  上面代码要指出的是：看似时间复杂度是 2n，一般我们都省取去时间复杂度的常数系数 \n\n+ 平方时间 $O(n^{2})$\n\n  经历过两遍最深循环\n\n  for example:\n  \n  ```伪代码\n  int n;\n  for i = 1 to n\n  \tfor j = 1 to n\n  \t\tdo something here.\n  ```\n  \n+ 对数时间 $O(\\log{n})$\n\n  在增加每一个输入时，额外时间会变小，这种情况，就是对数时间。\n\n  for example:(二分查找)\n\n  ```c\n  int search(int key, int a[], int length){\n      int ret = -1;\n      int left = 0;\n      int right = length - 1;\n      while(right >= left){\n          int mid = (left + right) / 2;\n          if(a[mid] == key){\n              ret = mid;\n              break;\n          } else if(a[mid] > key) {\n              right = mid - 1;\n          } else {\n              left = mid + 1;\n          }\n      }\n      return ret;\n  }\n  ```","tags":["算法"],"categories":["算法竞赛"]},{"title":"单向链表","url":"/2020/08/16/单向链表/","content":"\n## 何为单向链表\n\n链表是一种数据结构，你可以把它想象成一种动态的数组，此数组大小不固定，可以在需要时动态增加、删除元素。它解决了使用数组时大小固定不可更改的痛点。\n\n![单向链表示意图](https://img-blog.csdnimg.cn/20200816141744697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70#pic_center)\n\n<!-- more -->\n\n如上图所示，单向链表主要由一个一个节点组成。每个节点包含一个值 `Value` 和一个指针 `* next` ，值 `Value` 用于存储链表中的数值，指针 `* next` 用于指向下一个节点。\n\n定义一个指针 `* Head` 用于指向链表头节点。\n\n头节点的作用：表示单向链表的头部（不存放具体数据）。\n\n设定最后一个节点的 `* next` 的地址为 `NULL` ，表示链表末尾。\n\n## 链表节点\n\n使用结构体定义链表节点:\n\n```c\ntypedef struct _node\n{\n\tDataType value;\t\t//DataType代表实际中的值类型，例如可以 typedef int DataType\n\tstruct _node *next; //链接到下一个节点\n} Node;\n```\n\n随后，将整个链表做一封装：\n\n```c\ntypedef struct _list {\n\tNode* head;\t//指向链表第一个节点\n} List;\t\t\t//list可以代表整个链表\n```\n\n### 申请一个节点\n\n```c\nNode* CreateNode(DataType value) {\n    Node* pNode = (Node*)malloc(sizeof(Node));\n    pNode->value = value;\n    pNode->next = NULL;\n    return pNode;\n}\n```\n\n## 链表初始化\n\n初始化部分，将链表头 *head 设置为 NULL。\n\n```c\nvoid initList(List* pList) {\n    assert(pList);\t//检验参数合法性\n    pList->head = NULL;\n}\n```\n\n## 增加元素\n\n### 在链表末尾增加元素\n\n尾插，首先我们要创建一个新节点，然后判断链表当前是否有节点，若没有，则直接让第一个节点指向新节点，若有，找到最后一个节点，让他指向新节点。\n\n```c\nvoid add_at_end (List* pList, DataType value) {\n    assert(pList);\t//检验参数合法性\n    Node* pNewNode = CreateNode(value);\t//申请新节点存放元素\n    Node* last = pList->head;\t\t\t//last用于标识原链表中的末尾节点\n    //判断当前有无非头节点\n    if (last) {\n        while (last->next) {\t//如果last->next不为NULL，说明还不是原链表末尾节点\n            last = last->next;\t//不是原链表末尾节点，last后移\n        }\n        last->next = pNewNode;\t//找到原链表末尾节点，让其指向已申请的新节点\n    } else {\t// last为Null，说明只有头节点，直接让头节点指向已申请的新节点\n        pList->head = pNewNode;\n    }\n}\n```\n\n### 在指定位置增加元素\n\n在给定pos位置后插入值为value的节点，分两步完成：首先找到pos位置的节点，然后再插入，所以要实现这一个功能需要两个函数来共同完成。\n\n<img src=\"https://img-blog.csdnimg.cn/20200816141650163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\" style=\"zoom:50%;\" />\n\n**注意**：应该先连接好新节点，再断开原来的指针指向。\n\n```c\nvoid add_at_pos(Node* pos, DataType value) {\n    Node* pNewNode = NULL;\n    if(pos == NULL) {\n        return;\n    }\n    pNewNode = CreateNode(value);\n    \n    pNewNode->next = pos->next;\n    pos->next = pNewNode;\n}\n```\n\n+ 参数 `pos` 可由函数 `FindNode(&list, value)` 给出（见下文）。\n\n## 删除元素\n\n### 在链表末尾删除元素\n\n尾删，首先判断链表中有没有节点，若没有，直接返回，若有一个节点，直接让第一个节点指向NULL，若有多个节点，则需要记录下倒数第二个节点，让它指向NULL。\n\n<img src=\"https://img-blog.csdnimg.cn/20200816141812523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\" style=\"zoom: 50%;\" />\n\n```c\nvoid del_at_end(List* pList) {\n\tassert(pList);\t//检验参数合法性\n\tif (pList->head == NULL) {\t//链表中没有节点\n\t\treturn;\n    } else if (pList->head->next == NULL) {\t//只有一个节点\n        free(pList->head);\n        pList->head = NULL;\n    } else {                     //多个节点\n        Node* pCur = pList->head;\n        Node* pPre = NULL;\n        while (pCur->next) {\n            pPre = pCur;\n            pCur = pCur->next;\n        }\n        free(pCur);\n        pPre->next = NULL;\n    }\n}\n```\n\n### 在指定位置删除元素\n\n<img src=\"https://img-blog.csdnimg.cn/20200816142741217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hzaW5nWWFuZw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\" style=\"zoom:50%;\" />\n\n```c\nvoid del_at_pos(List* pList, Node* pos) {\n    assert(pList);\t//检验参数合法性\n    if (pos == NULL || pList->head == NULL) {\n        return;\n    }\n    if (pos == pList->head) {\n        pList->head = pos->next;\n    } else {\n        Node* pPrePos = pList->head;\n        while (pPrePos && pPrePos->next != pos) {\n            pPrePos = pPrePos->next;\n        }\n        pPrePos->next = pos->next;\n    }\n    free(pos);\n}\n```\n\n### 删除第一个值为value的节点\n\n要分三种情况：链表为空直接返回、要删除的节点为第一个节点、其它位置的节点。\n\n```c\nvoid del(List* pList, DataType value) {\n    assert(pList);\t//检验参数合法性\n    if (pList->head == NULL) {\n        return;\n    }\n    Node* pPre = NULL;\n    Node* pCur = pList->head;\n    while (pCur) {\n        if (pCur->value == value) {\n            if (pCur == pList->head) {\t//要删除的是第一个位置的节点\n                pList->head = pCur->next;\n            } else {\n                pPre->next = pCur->next;\t//其它位置的情况，让前一个节点指向其后一个节点\n            }\n            free(pCur);\n            return;\n        } else {\n            pPre = pCur;\n            pCur = pCur->next;\n        }\n    }\n}\n```\n\n## 改变元素的值\n\n更改pos位置节点的value值。\n\n```c\nvoid changevalue(Node* pos, value) {\t//此value为更改后的value\n    pos->value = value;   \n}\n```\n\n## 查找元素\n\n根据指定的value值，找到对应的节点。\n\n```c\nNode* FindNode(List* pList, DataType value){\n    assert(pList);\t//检验参数合法性\n    Node* pCur = pList->head;\n    while (pCur) {\n        if (pCur->value == value) {\n            return pCur;\n        }\n        pCur = pCur->next;\n    }\n    return NULL;\n} \n```\n\n## 打印链表\n\n```c\nvoid printList(List *pList)\n{\n    assert(pList); //检验参数合法性\n    Node *pCur = pList->head;\n    while (pCur)\n    {\n        printf(\"%d--->\", pCur->value);\n        pCur = pCur->next;\n    }\n    printf(\"\\n\");\n}\n```\n\n## 清除链表\n\n```c\nvoid destoryList(List *pList)\n{\n    assert(pList); //检验参数合法性\n    if (pList->head = NULL)\n    {\n        free(pList->head);\n        return;\n    }\n    while (pList->head)\n    {\n        Node *temp = pList->head->next;\n        free(pList->head);\n        pList->head = temp;\n    }\n}\n```\n","tags":["C语言","数据结构"],"categories":["2020暑假","数据结构与算法","链表"]},{"title":"2020暑假自学2：数组","url":"/2020/07/19/2020暑假自学02/","content":"> 一维数组 & 二维数组\n>\n> 20道算法\n>\n> <!-- more -->\n>\n\n## 01 - 两数之和\n\n+ 难度：简单\n+ 标签：`数组`、`哈希表`\n+ 链接：力扣 https://leetcode-cn.com/problems/two-sum\n\n### 题目\n\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n#### 示例\n\n```demo\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n### 解答\n\n由于没有学过任何算法，直接暴力解决好了。\n\n直接遍历，寻找符合`nums[i] + nums[j] == target`的 i 和 j 值。\n\n```c\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\n    int *ret = (int *)malloc(2*sizeof(int));\n    for(int i = 0; i<numsSize-1; i++){\n        for(int j = i + 1; j<numsSize; j++){\n            if(nums[i] + nums[j] == target){\n                ret[0] = i;\n                ret[1] = j;\n                *returnSize = 2;\n                return ret;\n            }\n        }\n    }\n    return NULL;\n}\n```\n\n成功！\n\n返回信息：\n\n+ 用时 184 ms，击败 55.58% 的 C 提交；\n+ 内存消耗 6.1 MB，击败 100% 的 C 提交；\n\n综合来看，暴力法内存消耗少，但用时长。\n\n另外，C语言模板看起来变量太多，不知其云云。比如这个 returnSize 看起来就很奇怪，而且其间接访问赋值的位置也斟酌好，必须在循环里赋值（大大的问号❓）。\n\nC++ 模板看起来清爽许多，但是需要 vector 的知识，以后回来再看：\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};\n```\n\n### 官方解答（java）\n\n暴力法不说，很简单。主要是掌握哈希表的方法：\n\n#### 方法一：暴力法\n\n暴力法很简单，遍历每个元素 x，并查找是否存在一个值与 target−x 相等的目标元素。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```\n\n\n复杂度分析：\n\n+ 时间复杂度：$O(n^2)$\n  对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)的时间。因此时间复杂度为 $O(n^2)$。\n\n+ 空间复杂度：O(1)。\n\n#### 方法二：两遍哈希表\n\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（`target - nums[i]）`是否存在于表中。注意，该目标元素不能是 `nums[i]` 本身！\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```\n\n复杂度分析：\n\n+ 时间复杂度：O(n)，\n  我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)，所以时间复杂度为 O(n)。\n\n+ 空间复杂度：O(n)，\n  所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。\n\n方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```\n\n复杂度分析：\n\n+ 时间复杂度：O(n)，\n  我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。\n\n+ 空间复杂度：O(n)，\n  所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。\n\n## 02 - 删除排序数组中的重复项\n\n+ 难度：简单\n+ 标签：`数组`、`双指针`\n+ 链接：力扣 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n### 题目\n\n给定一个排序数组，你需要在*原地*删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 *原地* **修改输入数组** 并在使用 O(1) 额外空间的条件下完成。\n\n#### 示例1\n\n```demo\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n#### 示例2\n\n```demo\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n```\n\n#### 说明\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```伪代码\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n### 提示\n\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" style=\"zoom: 20%;\" />\n\n+ In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image above for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements?\n\n+ We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements.\n\n+ Essentially, once an element is encountered, you simply need to **bypass** its duplicates and move on to the next unique element.\n\n### 解答\n\n定义i和j，i用于跟踪当前单元，j用于跳过重复单元，重新将不同于前一个的单元赋值给nums[++j]，循环结束后，j小于等于i，(j+1)必为新长度。\n\n```c\nint removeDuplicates(int* nums, int numsSize){\n    int i,j;\n    if(numsSize == 0) return 0;\n    for(i = 0,j = 0;i < numsSize; i++){\n        if(nums[i] != nums[j])\n            nums[++j] = nums[i]; \n    }\n    return j+1;\n}\n```\n\n返回信息：\n\n+ 用时 24 ms，击败 83.45% 的 C 提交；\n+ 内存消耗 8.1 MB，击败 100% 的 C 提交；\n\n## 03 - 一维数组的动态和\n\n+ 难度：简单\n+ 标签：`数组`\n+ 来源：力扣 https://leetcode-cn.com/problems/running-sum-of-1d-array/\n\n### 题目\n\n给你一个数组 `nums` 。数组「动态和」的计算公式为：`runningSum[i] = sum(nums[0] … nums[i])` 。\n\n请返回 `nums` 的动态和。\n\n#### 示例 1\n\n```demo\n输入：nums = [1,2,3,4]\n输出：[1,3,6,10]\n解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。\n```\n\n#### 示例 2\n\n```demo\n输入：nums = [1,1,1,1,1]\n输出：[1,2,3,4,5]\n解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。\n```\n\n#### 示例 3\n\n```demo\n输入：nums = [3,1,2,10,1]\n输出：[3,4,6,16,17]\n```\n\n#### 提示\n\n+ `1 <= nums.length <= 1000`\n+ `-10^6 <= nums[i] <= 10^6`\n\n### 解答\n\n没有难度，循环解之。注意是指针返回就行。\n\n```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* runningSum(int* nums, int numsSize, int* returnSize){\n    int *ret = (int *)malloc(numsSize*sizeof(int));\n    int sum = 0;\n    for(int i = 0;i < numsSize; i++){\n        sum += nums[i];\n        ret[i] = sum;\n    }\n    *returnSize = numsSize;\n    return ret;\n}\n```\n\n返回信息：\n\n+ 用时 8 ms，击败 90.07% 的 C 提交；\n+ 内存消耗 6.4 MB，击败 100% 的 C 提交；\n\n### 官方解答(java)\n\n+ 方法一：**暴力解法**时间复杂度O(n^2)\n\n  ```java\n  class Solution {\n      public int[] runningSum(int[] nums) {\n          int temp[] = new int[nums.length];\n          temp[0] = nums[0];\n          for(int i = 1;i < nums.length; i++){\n              int ans = nums[i];\n              for(int j = i -1;j >= 0;j--){\n                  ans += nums[j];\n              }\n              temp[i] = ans;\n          }\n          return temp;\n      }\n  }\n  ```\n\n+ 方法二：**动态规划** 时间复杂度O(n)\n\n  动态求和公式：`temp[i] = temp[i-1] + nums[i]`;\n\n  ```java\n  class Solution {\n       public int[] runningSum(int[] nums) {\n           int temp[] = new int[nums.length];\n           temp[0] = nums[0];\n           for(int i = 1;i < nums.length ;i++){\n               temp[i] = temp[i-1] + nums[i];\n           }\n           return temp;\n       }\n   }\n  ```\n\n方法二的思路还蛮好，我喜欢！\n\n## 04 - 数组异或操作\n\n+ 难度：简单\n+ 标签：`位运算` 、`数组`\n+ 链接：力扣 https://leetcode-cn.com/problems/xor-operation-in-an-array/\n\n### 题目\n\n给你两个整数，n 和 start 。\n\n数组 `nums` 定义为：`nums[i] = start + 2*i`（下标从 0 开始）且 `n == nums.length` 。\n\n请返回 `nums` 中所有元素按位异或（**XOR**）后得到的结果。\n\n#### 示例一\n\n```demo\n输入：n = 5, start = 0\n输出：8\n解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n     \"^\" 为按位异或 XOR 运算符。\n```\n\n#### 示例二\n\n```demo\n输入：n = 4, start = 3\n输出：8\n解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.\n```\n\n#### 示例三\n\n```demo\n输入：n = 1, start = 7\n输出：7\n```\n\n#### 示例4\n\n```demo\n输入：n = 10, start = 5\n输出：2\n```\n\n### 解答\n\n```c\nint xorOperation(int n, int start){\n    int ret = start;\n    for(int i=1; i<n; i++){\n        ret = ret ^ (start += 2);\n    }\n    return ret;\n}\n```\n\n返回信息：\n\n+ 用时 0 ms，击败 100% 的 C 提交；\n+ 内存消耗 5 MB，击败 100% 的 C 提交；\n\n## 05 - 移动矩阵的元素\n\n+ 此题改编自2020年大学生计算机技能应用大赛决赛(C语言组)程序设计题\n\n### 题目\n\n实现一个矩阵按照上、下、左、右方向循环移动的小程序。用户通过输入数据，程序作出相应动作。\n\n规定：函数move_up的功能是向上移动，函数move_down的功能是向下移动，函数move_left的功能是向左移动，函数move_right的功能是向右移动，当用户输入q时，结束程序。\n\n给出的矩阵为：`{25, 33, 14, 28}, {19, 42, 57, 48}, {39, 53, 39, 34}, {27, 40, 77, 61}`\n\n参考效果：\n\n```demo\n原始矩阵:   \n25 33 14 28 \n19 42 57 48 \n39 53 39 34 \n27 40 77 61 \n\n\n输入移动的方向[向上1,向下2,向左3,向右4]:1\n输入移动的步数:2\n\n\n移动后的矩阵:\n39 53 39 34 \n27 40 77 61 \n25 33 14 28 \n19 42 57 48 \n退出请按q键后回车，继续请按任意键后回车\n\n\n输入移动的方向[向上1,向下2,向左3,向右4]:2\n输入移动的步数:3\n\n\n移动后的矩阵:\n27 40 77 61 \n25 33 14 28 \n19 42 57 48\n39 53 39 34\n退出请按q键后回车，继续请按任意键后回车\n\n\n输入移动的方向[向上1,向下2,向左3,向右4]:3\n输入移动的步数:1\n\n\n移动后的矩阵:\n40 77 61 27\n33 14 28 25\n42 57 48 19\n53 39 34 39\n退出请按q键后回车，继续请按任意键后回车\n\n\n输入移动的方向[向上1,向下2,向左3,向右4]:4\n输入移动的步数:2\n\n\n移动后的矩阵:\n61 27 40 77\n28 25 61 14\n48 19 28 57\n34 39 48 39\n退出请按q键后回车，继续请按任意键后回车q\n```\n\n+ 要求\n  1. 不改变已给出的代码；\n  2. 补充move_up、move_down、move_left、move_right函数；\n  3. 补充main()函数两个注释之间的代码：要求在此补充菜单式的控制流程，要求能够实现对上次变化后的矩阵进行循环横向转移(可设置转移方向和转移步数)；\n  4. 关于方向，规定：输入1，代表向上转移；输入2，代表向下转移；输入3，代表向上转移；输入4，代表向下转移；\n  5. 关于步数，规定：输入值为大于等于1的正整数。\n\n代码框架\n\n```c\n#include <stdio.h>\n#define N 4\nvoid move_up(int (*a)[N], int x){\n    /* 控制向上移动 */\n}\nvoid move_down(int (*a)[N], int x){\n    /* 控制向下移动 */\n}\nvoid move_left(int (*a)[N], int x){\n    /* 控制向上移动 */\n}\nvoid move_right(int (*a)[N], int x){\n    /* 控制向下移动 */\n}\nint main()\n{\n    int t[][N]={25,33,14,28,19,42,57,48,39,53,39,34,27,40,77,61},i,j,m,p;\n    char ch;\n    printf(\"原始矩阵:\\n\");\n    for(i=0; i<N; i++)\n    {\n        for(j=0; j<N; j++)\n        {\n            printf(\"%d \",t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    // 在下面写出菜单式控制流程代码\n    \n    // 在上面写出菜单时控制流程代码\n    return 0;\n}\n```\n\n### 代码实现\n\n思考清晰了就没什么难度，想清楚如何循环，每个循环的作用。\n\n#### move_up函数\n\n```c\nvoid move_up(int (*a)[N], int x)\n{\n    char temp;\n    for (int j = 0; j < N; j++) // 第 0 ~ N 列\n    {\n        for (int k = 0; k < x; k++) // 每列移动 k 次\n        {\n            temp = a[0][j];\n            for (int i = 1; i < N; i++) // 每一次的移动过程\n            {\n                a[i - 1][j] = a[i][j];\n            }\n            a[N - 1][j] = temp;\n        }\n    }\n}\n```\n\n#### move_down函数\n\n```c\nvoid move_down(int (*a)[N], int x)\n{\n    char temp;\n    for (int j = 0; j < N; j++) // 第 0 ~ N 列\n    {\n        for (int k = 0; k < x; k++) // 每列移动 k 次\n        {\n            temp = a[N - 1][j];\n            for (int i = N; i > 0; i--) // 每一次的移动过程\n            {\n                a[i][j] = a[i - 1][j];\n            }\n            a[0][j] = temp;\n        }\n    }\n}\n```\n\n#### move_left函数\n\n```c\nvoid move_left(int (*a)[N], int x)\n{\n\tchar temp;\n\tfor (int i = 0; i < N; i++) // 第 0 ~ N 行\n\t{\n\t\tfor (int k = 0; k < x; k++) // 每一行移动 x 次\n\t\t{\n\t\t\ttemp = a[i][0];\n\t\t\tfor (int j = 1; j < N; j++) //\t每一次的移动过程\n\t\t\t{\n\t\t\t\ta[i][j - 1] = a[i][j];\n\t\t\t}\n\t\t\ta[i][N - 1] = temp;\n\t\t}\n\t}\n}\n```\n\n#### move_right函数\n\n```c\nvoid move_right(int (*a)[N], int x)\n{\n\tchar temp;\n\tfor (int i = 0; i < N; i++) // 第 0 ~ N 行\n\t{\n\t\tfor (int k = 0; k < x; k++) // 每一行移动 x 次\n\t\t{\n\t\t\ttemp = a[i][N - 1];\n\t\t\tfor (int j = N; j > 0; j--) //\t每一次的移动过程\n\t\t\t{\n\t\t\t\ta[i][j] = a[i][j - 1];\n\t\t\t}\n\t\t\ta[i][0] = temp;\n\t\t}\n\t}\n}\n```\n\n#### 菜单式控制流程\n\n```c\ndo\n\t{\n\t\tprintf(\"\\n\\n输入移动的方向[向上1,向下2,向左3,向右4]:\");\n\t\tscanf(\"%d\", &m);\n\t\tprintf(\"输入移动的步数:\");\n\t\tscanf(\"%d\", &p);\n        switch (m)\n        {\n        case 1:\n            move_up(t, p);\n            break;\n        case 2:\n            move_down(t, p);\n            break;\n        case 3:\n            move_left(t, p);\n            break;\n        case 4:\n            move_right(t, p);\n            break;\n        }\n\t\tprintf(\"\\n\\n移动后的矩阵:\\n\");\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", t[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"退出请按q键，继续请按任意键后回车\");\n\t\tgetchar();\n\t\tch = getchar();\n\t} while (ch != 'q' && ch != 'Q');\n```\n\n## 06 - 有多少小于当前数字的数字\n\n+ 难度：简单\n+ 标签：`数组`、`哈希表`\n+ 链接：力扣 https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/\n\n### 题目\n\n给你一个数组 `nums`，对于其中每个元素 `nums[i]`，请你统计数组中比它小的所有数字的数目。\n\n换而言之，对于每个 `nums[i]` 你必须计算出有效的 `j` 的数量，其中 `j` 满足 `j != i` **且** `nums[j] < nums[i]` 。\n\n以数组形式返回答案。\n\n#### 示例1\n\n```demo\n输入：nums = [8,1,2,2,3]\n输出：[4,0,1,1,3]\n解释： \n对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]=1 不存在比它小的数字。\n对于 nums[2]=2 存在一个比它小的数字：（1）。 \n对于 nums[3]=2 存在一个比它小的数字：（1）。 \n对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。\n```\n\n#### 示例2\n\n```demo\n输入：nums = [6,5,4,8]\n输出：[2,1,0,3]\n```\n\n#### 示例3\n\n```demo\n输入：nums = [7,7,7,7]\n输出：[0,0,0,0]\n```\n\n#### 提示\n\n+ `2 <= nums.length <= 500`\n+ `0 <= nums[i] <= 100`\n\n### 解答\n\n暴力法，枚举解之。注意以malloc方式返回一个指针。\n\n```c\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\n    int* ret = (int*)malloc(numsSize*sizeof(int));\n    int count = 0;\n    for(int i = 0; i<numsSize; i++){\n        count  = 0;\n        for(int j = 0; j<numsSize; j++){\n            if(nums[j]<nums[i]) count++;\n        }\n        ret[i] = count;\n    }\n    *returnSize = numsSize;\n    return ret;\n}\n```\n\n返回信息：\n\n+ 用时 36 ms，击败 54.07% 的 C 提交；\n+ 内存消耗 6.3 MB，击败 100% 的 C 提交；\n\n分析：\n\n+ 时间复杂度高：枚举数组里的每个数字为 $O(n)$，遍历数组也为 $O(n)$，所以总时间复杂度为两者相乘，即 $O(n^2)$\n\n### 非暴力解法\n\n来自官方的非暴力解法：\n\n#### 1.频次数组 + 前缀和\n\n注意到数字的值域范围为 [0, 100]，所以可以考虑建立一个频次数组 cnt[i]，表示数字 i 出现的次数，那么对于数字 i 而言，它的答案就是\n\n$$\n\\sum_{j=0}^{i-1}{cnt[j]}\n$$\n即小于它的数字出现个数之和，直接算需要遍历 [0, i-1] 的 cnt 求和，仍需要线性的时间去计算，但我们注意到这个答案是一个前缀和，所以我们可以再对 cnt 数组求前缀和。那么对于数字 i 的答案就是 cnt[i-1] ，算答案的时间复杂度从 O(n) 降到了 O(1) 。\n\n最后整个算法流程为：遍历数组元素，更新 cnt 数组，即 `cnt[nums[i]]+=1` ，然后对 cnt 数组求前缀和，最后遍历数组元素，对于相应的数字 O(1) 得到答案即可。\n\n```c++\nclass Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        vector<int> cnt(101, 0);\n        vector<int> vec((int)nums.size(), 0);\n        for (int i = 0;i < (int)nums.size(); ++i){\n            cnt[nums[i]]++;\n        }   \n        for (int i = 1;i <= 100; ++i) cnt[i] += cnt[i-1]; // 求前缀和\n        for (int i = 0;i < (int)nums.size(); ++i){\n            if (nums[i]) vec[i] = cnt[nums[i] - 1];\n        } \n        return vec;\n    }\n};\n```\n\n复杂度分析\n\n+ 时间复杂度：统计 cnt 数组的前缀和需要 O(S) 的时间，遍历数组需要 O(n) 的时间，所以总时间复杂度为 O(S+n)，其中 S 为值域大小，n=nums.length。\n\n+ 空间复杂度：O(S) ，需要开一个值域大小的数组。\n\n#### 2.排序\n\n我们将 nums 数组按数字大小从小到大排序，那么对于第 i 个数字 x ，数组中在它前面的数字一定小于等于它，而题目要求小于它的数字个数，所以我们可以对于位置 i 记录一个变量 $pre_i$，表示位置 i 往前第一个不等于 x 的数字下标。对于数字 x ，答案就是 $pre_i+1$，因为数组下标是从 0 开始的，所以需要额外加一。$pre_i$ 需要分两种情况更新，如果前面一个数字等于当前数字 x ，那么 $pre_i=pre_{i-1}$，否则 $pre_i=i-1$，这样即能 O(1) 推出 $pre_i$。\n\n同时注意到 $pre_i$ 只与前一个位置有关，所以可以不用数组存 $pre_i$，直接用一个变量 pre 表示前一个位置的 $pre_{i-1}$，然后不断更新 pre 即可。\n\n最后整个算法流程为：对每个数字用一个二元组 ($number_i, index\\ of\\ number_i$) 表示数字大小和数字在 nums 数组中的下标，用 tmp 数组存储所有二元组，按数字 $number_i$ 从小到大排序 tmp 数组，最后遍历 tmp 数组，按上文说的方法的维护 pre 变量，对于 tmp 数组里第 i 个元素的答案，应放在答案数组中的第 $index\\ of\\ number_i$ 个位置里 。\n\n```c++\nclass Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        int n = (int)nums.size();\n        vector<pair<int,int> > tmp;tmp.clear();\n        vector<int> vec(n, 0);\n        for (int i = 0;i < n; ++i){\n            tmp.push_back(make_pair(nums[i], i));\n        }\n        sort(tmp.begin(), tmp.end());\n        int pre = -1;\n        for (int i = 0;i < n; ++i){\n            if (i == 0) vec[tmp[i].second] = pre + 1;\n            else if (tmp[i].first == tmp[i-1].first) vec[tmp[i].second] = pre + 1;\n            else{\n                pre = i - 1;\n                vec[tmp[i].second] = pre + 1;\n            }\n        }\n        return vec;\n    }\n};\n```\n\n复杂度分析\n\n+ 时间复杂度：排序需要 $O(n\\log n)$ 的时间复杂度，遍历数组需要 O(n) 的时间复杂度，所以总的时间复杂度为 $O(n\\log n+n)=O(n\\log n)$ 。\n\n+ 空间复杂度：上文提及的 tmp 数组需要 O(n) 的空间，空间复杂度为 O(n) 。","tags":["算法"],"categories":["2020暑假"]},{"title":"2020暑假自学1：基础算法回顾","url":"/2020/07/14/2020暑假自学01/","content":"> 1. 欧几里得算法求最大公约数\n> 2. 筛法求素数\n> 3. 康托展开\n> 4. 逆康托展开\n> 5. 同余定理\n> 6. 高次方求模\n> 7. 三角形面积（海伦公式）\n> 8. 三点顺序\n>\n> <!-- more -->\n\n\n## 一、欧几里得算法求公约数\n\n```c\n#include <stdio.h>\nint gcd(int a,int b){\n\tint temp;\n\twhile (b)\n\t{\n\t\ttemp = a % b;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\treturn a;\n}\nint main(int argc, char *argv[])\n{\n\tint a, b;\n\tprintf(\"please input the number a and b:\\n\");\n\tprintf(\"a = \");\n\tscanf(\"%d\",&a);\n\tprintf(\"b = \");\n\tscanf(\"%d\",&b);\n\tprintf(\"The gcd of a(%d) and b(%d) is %d.\\n\",a,b,gcd(a,b));\n\treturn 0;\n}\n```\n\n## 二、筛法求素数\n\n> 用筛法求素数的基本思想是：把从1开始的、某一范围内的正整数从小到大顺序排列， 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的倍数。依次类推，直到筛子为空时结束。\n\n### 算法\n\n欲筛法求素数，先构造n以内的素数表：\n\n1. x从1开始，判断x是否为素数\n\n2. 若x为素数，则筛去x的小于n的所有倍数\n\n   若x不为素数，跳过此步骤\n\n3. x++，直至x<n\n\n然，从表中判断。\n\n### 示例程序\n\n```c\n#include <stdio.h>\nint main(int argc, char *argv[])\n{\n\tconst int MAX = 1e6;\n\tbool isPrime[MAX];\n\tint number;\n\t// 开辟prime[MAX]，初始其所有元素为1，prime[x]为true表示x是素数\n\tfor (int i = 0; i < MAX; i++)\n\t\tisPrime[i] = true;\n\tfor (int x = 2; x < MAX; x++)\n\t{\n\t\tif (isPrime[x])\n\t\t\tfor (int i = 2; i * x < MAX; i++)\n\t\t\t\tisPrime[i * x] = false;\n\t}\n\tprintf(\"please input the number you want to know whether it's a prime:\\n\");\n\tscanf(\"%d\", &number);\n\tif (isPrime[number])\n\t\tprintf(\"It's a prime!\\n\");\n\telse\n\t\tprintf(\"It isn't a prime!\\n\");\n\treturn 0;\n}\n```\n\n## 三、康托展开\n\n> **康托展开**是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。（[百度百科](https://baike.baidu.com/item/康托展开)）\n\n### 通俗理解\n\n康托展开可以求解一个排列的序号，比如：12345 序号为 1 ，12354序号为2，按字典序增加编号递增，依次类推。\n康托逆展开可以求解一个序号它对应的排列是什么。\n\n### 康托展开公式\n\n给定一个全排列，计算其字典序。直观起见，我们举例[2, 3, 4, 1]来说明康托展开的运作步骤（在[1,2,3,4]的4位排列组合中）：\n\n命所求字典序为 `rank = 0`\n\n1. 第1位是2，那么以 1 打头的所有全排列一定排在这个全排列之前，以 1 打头的全排列有 (3!) = 6种。`rank += 1*3! = 6`\n2. 第 2 位是 3，那么以 1 与 2 作为第二位的所有全排列一定在这个圈排列之前。不过我们已经让 2 打头了，因此不需要再考虑 2 占第二位的情况，只需要计算 1 占第二位的情况。`rank += 1*2!= 8 `\n3. 第3位是 4，同时，我们计算以 1 占第三位的所有情况。`rank += + 1∗1! = 9`\n4. 最后一位，是不需要判定的，因为前 n−1 位给定后，第 n 位自定。`rank += + 0∗0! = 9`\n\n由是，排在 [2, 3, 4, 1] 之前的全排列共有 9 个，那么 [2, 3, 4, 1] 应当是第 **10** 个全排列。\n\n总结康托展开公式为：\n\n$$rank=a_{n}(n-1) !+a_{n-1}(n-2) !+\\cdots+a_{1} \\cdot 0 !$$\n\n其中，$a_i$​ 表示原排列中，排在下标 i 后面的，比下标 i 的字符还小的字符个数。当然，如果排名是从 1 开始的话，最终结果应当再 + 1。\n\n<p align=\"right\">资料来源:<a href=\"https://blog.csdn.net/ajaxlt/article/details/86544074\">CSDN</a></p>\n\n### 示例代码\n\n```c\nconst int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}; //\t0-10的阶乘\n//cantor展开，n表示是n位的全排列，a[]表示全排列的数(用数组表示)\nint cantor(int a[], int n)\n{\n\tint ans = 0, sum = 0;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tif (a[j] < a[i])\n\t\t\t\tsum++;\n\t\t}\n\t\tans += sum * fact[n - i]; //\t累积\n\t\tsum = 0;\t\t\t\t  //\t计数器归零\n\t}\n\treturn (ans + 1);\n}\n```\n\n## 四、逆康托展开\n\n即给出序号，求出组合数。\n\n### 展开举例\n\n在[1,2,3,4]的4位排列组合中，给出10可以算出第10位排列组合位[2，3，4，1]。\n\n给定，字符个数 4，字典序序号 10，首先字典序 - 1 得到排在该字典序前的全排列个数，然后：\n\n1. 9 ÷ 3! 结果，商 1 余 3，说明比首位小的数有1个。因此，我们应当使用 “2” 作为首位，并标记其已经使用。取余数进行下一步操作。\n2. 3 ÷ 2! 结果，商 1 余 1，说明比第2位小的数有1个。这里 “2” 虽然用过，但 “1” 没用过。因此，我们应当使用 “3” 作第二位。\n3. 1 ÷ 1! 结果，商 1 余 0，说明比第2位小的数有1个。这里 “1” 没有用过，“2” 已经用了，“3”也用了。因此，我们应当使用 “4” 作第三位。\n4. 同康托展开，最后一位无需判断，所有字符中至今未使用的填入即可。\n\n<p align=\"right\">资料来源:<a href=\"https://blog.csdn.net/ajaxlt/article/details/86544074\">CSDN</a></p>\n\n### 示例代码\n\n```c\n#include <stdio.h>\n#include <math.h>\n#include <stdbool.h>\nconst int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}; //\t0-10的阶乘\nbool used[11];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t //\t判断是否用过\n//cantor展开逆运算，rank表示第rank位的全排列数，length表示全排列位数长度\nint de_cantor(int rank, int length)\n{\n\tint ans = 0, sum = 0;\t //\tans存储答案，sum暂时计数\n\tint quotient, remainder; //\tquotient商，remainder余数\n\tfor (int i = length - 1; i >= 1; i--)\n\t{\n\t\tquotient = rank / fact[i];\n\t\tremainder = rank % fact[i];\n\t\tfor (int j = 1; j <= length; j++)\n\t\t{\n\t\t\tif (!used[j])\n\t\t\t{\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tif (sum == quotient + 1) //\t找到该位\n\t\t\t{\n\t\t\t\tans += j * pow(10, i);\n\t\t\t\tsum = 0; //\t清零\n\t\t\t\trank = remainder;\n\t\t\t\tused[j] = true; //标记为用过\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= length; i++)\n\t{\n\t\tif (!used[i])\n\t\t{\n\t\t\tans += i;\n\t\t\tbreak;\n\t\t}\n\t} //\t最后一位\n\treturn ans;\n}\n```\n\n## 五、同余定理\n\n> 数论中的重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。（[百度百科](https://baike.baidu.com/item/康托展开)）\n\n### 应用举例\n\n<p style=\"color:red;font-weight:900\">\n    自然数16520、14903、14177除以m得到相同的余数，m最大的数值等于多少？\n</p>\n\n\n三个数字比较大，但是他们对于m同余，那么当中任意两个数字的差必然是m的倍数，要求m的最大的数值可以转化位求他们的三个差的最大公约数，从而降低计算的难度\n\n> 16520 - 14903 = 1617 = 3 × 7 × 7 × 11,\n>\n> 16520 - 14177 = 2343 = 3 × 11 × 71,\n>\n> 14903 - 14177 = 726 = 2 × 3 × 11 × 11,\n>\n> **三个差的最大公约数是 3 × 11 = 33，m的最大数字等于33**\n\n+ 思路\n  1. 输入三个数\n  2. 求三个数的差\n  3. 先求前两个数的最大公约数t,再求t和第三个数的最大公约数（求最大公余数可借助辗转相除法）\n\n<p align=\"right\">资料来源:<a href=\"https://blog.csdn.net/u013599298/article/details/49949539\">CSDN</a></p>\n\n### 示例算法\n\n扩展到n个数，n个数除以m得到相同的的余数，求m的最大值：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#define Max 100\nint num[Max]; //原始序列\nint val[Max]; //每两个数之间的差\n//最大公约数\nint gcd(int a, int b)\n{\n\tint temp;\n\twhile (b)\n\t{\n\t\ttemp = a % b;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\treturn a;\n}\n//用同余定理处理求n的数的余数，num[]原始序列，n元素个数\nint my_remainder(int num[], int n)\n{\n\tint i = 0, j = 0, k = 0;\n\t//处理得到val[]，即每两个数之间的差值\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tfor (j = i + 1; j < n; j++)\n\t\t{\n\t\t\tval[k++] = abs(num[i] - num[j]);\n\t\t}\n\t}\n\t//求val[0]和val[1]求最大公约数t，然后再对t和val[i](i>=2)求最大公约数，\n\t//一直到最后一个，得出val数组中的最大公约数即为所求\n\tint t = gcd(val[0], val[1]);\n\tfor (i = 2; i < n; i++)\n\t{\n\t\tt = gcd(val[i], t);\n\t}\n\treturn t;\n}\n\nint main()\n{\n\tint n;\n\tprintf(\"Pleas input the number of the elements:\");\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tprintf(\"Please input the NO.%d element:\", i + 1);\n\t\tscanf(\"%d\", &num[i]);\n\t}\n\tprintf(\"%d is the largest remainder of this %d elements.\\n\", my_remainder(num, n), n);\n\treturn 0;\n}\n```\n\n> 🔺注意：不将此处取余函数命名为 `remainder`，此函数已在 `math.h` 中声明。(C99)\n\n## 六、高次幂取模\n\n对于 $a^{b} \\bmod m$ ,当b的值很大时,直接求解不可能,那怎样做呢?\n\n主要思想是**分治**,分而治之.将大的问题分成若干个相似的较小的问题!\n\n具体实现是用递归的方法!\n\n### 模运算\n\n首先要了解些模运算的法则,才可知道如何实现递归.\n\n+ $(a \\pm  b) \\% p = (a \\% p \\pm b \\% p) \\% p$\n+ $(a \\times  b) \\% p = (a \\% p \\times b \\% p) \\% p$\n+ $(a ^  b) \\% p = ((a \\% p) ^ b) \\% p$\n\n### 示例\n\n$$ 2^{100} \\bmod 3$$\n\n+ $2^{100}=(2^{50})^{2}=((2^{25})^{2})^{2}=((((2^1)^2)^2)\\cdots)^{2}$\n\n+ 最终知道$2^1\\bmod3$的值，根据模运算递归得 $2^{100} \\bmod 3$的值\n\n+ 当然，还要根据奇偶性区分：\n\n  $2^{100}=(2^{50})^2=\\cdots$\n\n  $2^{99}=(2^{49})^2\\times2=\\cdots$\n\n### 代码实现\n\n```c\nlong mod(long a, long b, long m)\n{\n\tlong ret;\n\tif (!b)\n\t\tret = 1; //\t边界处理，b==0\n\telse if (b == 1)\n\t\tret = a % m; //\t边界处理，b==1\n\telse\n\t{\n\t\tret = mod(a, b / 2, m);\t//\t递归\n\t\tret = ret * ret % m;\t//\t先算偶数的（奇数第一部分和此一样）\n\t\tif (b & 1)\t//\t当指数为奇数,多乘第二部分\n\t\t\tret = (ret * a % m)%m;\n\t}\n\treturn ret;\n}\n```\n\n> 小技巧：奇数的二进制最后一位是1，用位运算判断奇数：number & 1，结果为1则为真。\n\n## 七、海伦公式\n\n### 公式表述\n\n假设在平面内，有一个三角形，边长分别为a、b、c，三角形的面积S可由以下公式求得：\n\n$s=\\sqrt{p(p-a)(p-b)(p-c)}$ （p为半周长）\n\n### 代码示例\n\n算面积只要套公式就行，并无难度，但要注意三边长是否可以组成三角形，给出友好的提示。\n\n```c\n#include <stdio.h>\n#include <math.h>\ndouble area_tri(double a, double b, double c)\n{\n\tdouble area = 0;\n\tdouble p = (a + b + c) / 2.0;\n\tif (a + b <= c || a + c <= b || b + c <= a)\n\t\tarea = 0;\n\telse\n\t\tarea = sqrt(p * (p - a) * (p - b) * (p - c));\n\treturn area;\n}\nint main(int argc, char *argv[])\n{\n\tdouble a, b, c;\n\tprintf(\"Please input the length of 3 sides:\\n\");\n\tprintf(\"a = \");\n\tscanf(\"%lf\", &a);\n\tprintf(\"b = \");\n\tscanf(\"%lf\", &b);\n\tprintf(\"c = \");\n\tscanf(\"%lf\", &c);\n\tif (area_tri(a, b, c))\n\t\tprintf(\"Its perimeter is %.2f.\\n\", area_tri(a, b, c));\n\telse\n\t\tprintf(\"These sides do not correspond to a valid triangle!\\n\");\n\treturn 0;\n}\n```\n\n## 八、三点顺序\n\n### 描述\n\n现在给你三个点A,B,C的坐标，它们可能能组成一个三角形，现在让你判断A，B，C是顺时针给出的还是逆时针给出的，或是三点共线？\n\n如：\n\n<img src=\"https://cdn.jsdelivr.net/gh/diandengjun/cdn@0.1.1.9/post/2020/07/13/tri.png\" style=\"zoom: 80%;\" />\n\n### 思路\n\n利用矢量叉积判断是逆时针还是顺时针。\n\n设A(x1,y1),B(x2,y2),C(x3,y3),则三角形两边的矢量分别是：\n\nAB=(x2-x1,y2-y1), AC=(x3-x1,y3-y1)\n\n则AB和AC的叉积为：\n\n$$\\begin{vmatrix}x_2-x_1 & y_2-y_1 \\\\ _3-x_1 & y_3-y_1\\end{vmatrix}=(x_2-x_1)\\cdot(y_3-y_1)-(y_2-y_1)\\cdot(x_3-x_1)$$\n\n根据数学知识，利用右手法则进行判断\n\n1. 如果 AB × AC > 0，说明方向从 AB→AC 得到向量积，即这里的三角形ABC逆时针\n2. 如果 AB × AC < 0，说明方向从 AC→AB 得到向量积，即这里的三角形ABC顺时针\n3. 如果 AB × AC = 0，说明三点共线\n\n### 代码实现\n\n```c\n#include <stdio.h>\ntypedef struct _point\n{\n\tdouble x;\n\tdouble y;\n} Point;\nint main(int argc, char *argv[])\n{\n\tPoint A, B, C;\n\tprintf(\"Please input 3 points:\\n\");\n\tprintf(\"\\tx of Point A:\");\n\tscanf(\"%lf\", &A.x);\n\tprintf(\"\\ty of Point A:\");\n\tscanf(\"%lf\", &A.y);\n\tprintf(\"\\tA(%.2f,%.2f)\\n\",A.x,A.y);\n\tprintf(\"\\n\\tx of Point B:\");\n\tscanf(\"%lf\", &B.x);\n\tprintf(\"\\ty of Point B:\");\n\tscanf(\"%lf\", &B.y);\n\tprintf(\"\\tB(%.2f,%.2f)\\n\",B.x,B.y);\n\tprintf(\"\\n\\tx of Point C:\");\n\tscanf(\"%lf\", &C.x);\n\tprintf(\"\\ty of Point C:\");\n\tscanf(\"%lf\", &C.y);\n\tprintf(\"\\tC(%.2f,%.2f)\\n\",C.x,C.y);\n\tdouble ans = (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);\n\tif (!ans)\n\t\tprintf(\"Three points are collinear!\\n\");\n\telse if (ans > 0)\n\t\tprintf(\"Anti-Clockwise!\\n\");\n\telse\n\t\tprintf(\"clockwise!\\n\");\n\treturn 0;\n}\n```\n\n## 总结\n\n这些看似简单的小程序其实很大一部分和数论有关，都是数论与编程的结合，可见，数学的基本功对计算机专业的重要性。","tags":["C语言","算法"],"categories":["2020暑假"]},{"title":"2020全国大学生计算机技能应用大赛决赛C语言编程题摘录","url":"/2020/07/13/2020计算机技能大赛/","content":"> 记录决赛两道编程题，比赛时由于时间紧张和经验不足，未有效完成。\n> 现记录并完善。\n<!-- more -->\n\n## 综合应用题\n\n### 题目\n\n2020年是特殊的一年，COVID-19 的传播给全世界都带来了极大的威胁。中国在疫情防治工作上有着突出表现，向社会、世界都做出了极大的贡献，让我们一同为祖国点赞。疫情防治工作，重在预防，各个地区都应当相互学习合适又优秀的防疫措施。如果能够依据现有的疫情数据分析出具有相似疫情情况的地区，那么对于挖掘疫情发展规律、分析疫情防控效能和落实疫情防治举措都会有积极的影响。现给出5个地区的当前疫情数据，请分析出疫情最相似的两个地区。具体要求如下:\n\n1. 使用C语言程序设计实现;\n\n2. 为每个地区的疫情情况构建结构体，该结构体包括以下属性:\n   地区名、新增患者数、现有患者数、累积患者数、治愈患者数、死亡患者数。\n\n3. 相似程度算法如下:\n   $$sim(x,y)=\\frac{\\sum_{i=1}^{n}{(x_i\\cdot y_i )} }{\\sqrt{\\sum_{i=1}^{n}{(x_i^2)} }\\cdot \\sqrt{\\sum_{i=1}^{n}{(y_i^2)} }}$$\n\n   其中，i 指的是 x 和 y 对象的第 i 维特征。sim越大，则两个对象越相似。\n\n4. 现有的5个地区的当前疫情数据是:\n\n   | 序号 | 地区名 | 新增患者数 | 现有患者数 | 累积患者数 | 治愈患者数 | 死亡患者数 |\n   | ---- | ------ | ---------- | ---------- | ---------- | ---------- | ---------- |\n   | 1    | cityA  | 3          | 3          | 582        | 573        | 6          |\n   | 2    | cityB  | 4          | 3          | 238        | 234        | 1          |\n   | 3    | cityC  | 5          | 3          | 197        | 191        | 3          |\n   | 4    | cityD  | 3          | 2          | 692        | 683        | 7          |\n   | 5    | cityE  | 6          | 2          | 171        | 163        | 6          |\n\n5. 要求提供数据输入功能。\n\n   要求输出部分必须有最相似的两个地区的名字。\n\n   输入输出样例：\n\n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn@0.1.1.8/post/2020/07/13/carbon.png\" style=\"zoom:50%;\" />\n\n<p align=\"right\">（有改编）</p>\n\n### 代码实现\n\n```c\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\ntypedef struct _City\n{\n\tchar name[50];\n\tint add;\n\tint exist;\n\tint count;\n\tint cure;\n\tint die;\n} City;\n// 定义_similarity结构体用于存最大的相似值\ntypedef struct _similarity\n{\n\tchar name1[50];\n\tchar name2[50];\n\tdouble sim_number;\n} similarity;\n// 根据公式求相似值\ndouble sim(City x, City y)\n{\n\tint sum1 = 0, sum2 = 0, sum3 = 0;\n\tsum1 = x.add * y.add + x.exist * y.exist + x.count * y.count + x.cure * y.cure + x.die * y.die;\n\tsum2 = x.add * x.add + x.exist * x.exist + x.count * x.count + x.cure * x.cure + x.die * x.die;\n\tsum3 = y.add * y.add + y.exist * y.exist + y.count * y.count + y.cure * y.cure + y.die * y.die;\n\treturn sum1 / sqrt(sum2) / sqrt(sum3);\n}\nint main(int argc, char *argv[])\n{\n\tint n;\n\tprintf(\"Pleas input the number of cities:\");\n\tscanf(\"%d\", &n);\n\tCity city[n];\n\tprintf(\"\\nPleas input the information of %d cities:\\n\", n);\n    //输入各个结构体\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tprintf(\"NO.%d city:\\n\", i + 1);\n\t\tprintf(\"\\tCity name:\");\n\t\tscanf(\"%s\", city[i].name);\n\t\tprintf(\"\\tNumber of new patients:\");\n\t\tscanf(\"%d\", &city[i].add);\n\t\tprintf(\"\\tNumber of existing patients:\");\n\t\tscanf(\"%d\", &city[i].exist);\n\t\tprintf(\"\\tCumulative number of patients:\");\n\t\tscanf(\"%d\", &city[i].count);\n\t\tprintf(\"\\tNumber of patients cured:\");\n\t\tscanf(\"%d\", &city[i].cure);\n\t\tprintf(\"\\tNumber of patients died:\");\n\t\tscanf(\"%d\", &city[i].die);\n\t\tprintf(\"\\n\");\n\t}\n    //先将最相似定义为第一个city和第二个city\n\tsimilarity most_like;\n\tstrcpy(most_like.name1, city[0].name);\n\tstrcpy(most_like.name2, city[1].name);\n\tmost_like.sim_number = sim(city[0], city[1]);\n\tprintf(\"-------------------------------------------------------------------\\n\");\n\tprintf(\"The results of the analysis between each two cities are as follows:\\n\");\n    //分析每两个之间的相似值，并记录相似值最大的那两个\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tprintf(\"The similarity of epidemic situation between %s and %s: %.6f\\n\", city[i].name, city[j].name, sim(city[i], city[j]));\n\t\t\tif (most_like.sim_number < sim(city[i], city[j]))\n\t\t\t{\n\t\t\t\tstrcpy(most_like.name1, city[i].name);\n\t\t\t\tstrcpy(most_like.name2, city[j].name);\n\t\t\t\tmost_like.sim_number = sim(city[i], city[j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"%s and %s are the most similar!\", most_like.name1, most_like.name2);\n\treturn 0;\n}\n```\n\n## 程序设计题\n\n### 题目\n\n实现一个矩阵左右循环移动的小程序。用户通过输入数据，程序作出相应动作。规定：函数fun1的功能是向左移动，函数fun2的功能是向右移动，当用户输入q时，结束程序。在给出代码框架中，可以决定是否使用全局变量r。\n\n参考输入输出：\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn@0.1.1.8/post/2020/07/13/carbon1.png\" style=\"zoom:50%;\" />\n\n要求：\n\n1. 不改变已给出的代码；\n2. 补充fun1和fun2函数；\n3. 补充main()函数两个注释之间的代码：要求在此补充菜单式的控制流程，要求能够实现对上次变化后的矩阵进行循环横向转移(可设置转移方向和转移步数)；\n4. 关于方向，规定：输入1，代表向左转移；输入2，代表向右转移；\n5. 关于步数，规定：输入值为大于等于1的正整数。\n\n代码框架：\n\n```c\n#include <stdio.h>\n#define N 4\nint r[4][4];\nvoid fun1(int (*a)[N], int x){\n    /* 控制向左移动 */\n}\nvoid fun2(int (*a)[N], int x){\n    /* 控制向右移动 */\n}\nint main()\n{\n    int t[][N]={25,33,14,28,19,42,57,48,39,53,39,34,27,40,77,61},i,j,m,p;\n    char ch;\n    printf(\"原始矩阵:\\n\");\n    for(i=0; i<N; i++)\n    {\n        for(j=0; j<N; j++)\n        {\n            printf(\"%d \",t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    // 在下面写出菜单式控制流程代码\n    \n    // 在上面写出菜单时控制流程代码\n    return 0;\n}\n```\n\n\n<p align=\"right\">（有改编）</p>\n\n### 代码实现\n\n我觉得思考清晰了就没什么难度，想清楚如何循环，每个循环的作用。\n\n```c\n#include <stdio.h>\n#define N 4\nvoid fun1(int (*a)[N], int x)\n{\n\tchar temp;\n\tfor (int i = 0; i < N; i++) // 第 0 ~ N 行\n\t{\n\t\tfor (int k = 0; k < x; k++) // 每一行移动 x 次\n\t\t{\n\t\t\ttemp = a[i][0];\n\t\t\tfor (int j = 1; j < N; j++) //\t每一次的移动过程\n\t\t\t{\n\t\t\t\ta[i][j - 1] = a[i][j];\n\t\t\t}\n\t\t\ta[i][N - 1] = temp;\n\t\t}\n\t}\n}\nvoid fun2(int (*a)[N], int x)\n{\n\tchar temp;\n\tfor (int i = 0; i < N; i++) // 第 0 ~ N 行\n\t{\n\t\tfor (int k = 0; k < x; k++) // 每一行移动 x 次\n\t\t{\n\t\t\ttemp = a[i][N - 1];\n\t\t\tfor (int j = N; j > 0; j--) //\t每一次的移动过程\n\t\t\t{\n\t\t\t\ta[i][j] = a[i][j - 1];\n\t\t\t}\n\t\t\ta[i][0] = temp;\n\t\t}\n\t}\n}\nint main()\n{\n\tint t[][N] = {{25, 33, 14, 28}, {19, 42, 57, 48}, {39, 53, 39, 34}, {27, 40, 77, 61}}, i, j, m, p;\n\tchar ch;\n\tprintf(\"原始矩阵:\\n\");\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t{\n\t\t\tprintf(\"%d \", t[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tdo\n\t{\n\t\tprintf(\"\\n\\n输入移动的方向[向左1,向右2]:\");\n\t\tscanf(\"%d\", &m);\n\t\tprintf(\"输入移动的步数:\");\n\t\tscanf(\"%d\", &p);\n\t\tif (m == 1)\n\t\t\tfun1(t, p);\n\t\telse\n\t\t\tfun2(t, p);\n\t\tprintf(\"\\n\\n移动后的矩阵:\\n\");\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", t[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"退出请按q键，继续请按任意键后回车\");\n\t\tgetchar();\n\t\tch = getchar();\n\t} while (ch != 'q' && ch != 'Q');\n    return 0;\n}\n```","tags":["C语言"],"categories":["编程题"]},{"title":"免费领阿里云服务器？","url":"/2020/07/04/免费领阿里云服务器？/","content":"> 快！免费领取一年阿里云服务器！\n>\n> 仅限咱们学生党\n>\n> <!-- more -->\n\n## 拥有一台属于自己的服务器\n\n> 最近，阿里云推出了“阿里云高校计划”，凡是高校学生均有机会获得12个月免费使用阿里云服务器的资格！\n\n1. 首先登陆阿里云高校计划网站：https://developer.aliyun.com/adc/student/\n\n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn@0.1.1.4/post/2020/07/04/免费领阿里云服务器/截图1.png\" style=\"zoom: 50%;\" />\n\n2. 在页面中完成学生认证（需在学信网上有资料）\n3. 完成有关网络方面知识的答题（题目内容可参考：https://docs.qq.com/doc/DVktVWFpUQ0FxQUR5 ）\n\n完成以上内容即可领取阿里云服务器了！\n\n要注意的是：领取的ECS（弹性云服务器），有效期为6个月，云服务器ECS到期释放前30天内，可登录个人中心，参加阶段性学习考试，测试通过，可免费续期1次，时长为6个月。\n\n## 远程连接ECS\n\n### 查看ECS控制台\n\n领取后，进入阿里云控制台，打开云服务器ECS面板，点击到`实例与镜像`>`实例`即可查看到当前所拥有的ECS。如果没有看到，请切换到服务器所在的地区（如华北2(北京)）。\n\n![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn@0.1.1.4/post/2020/07/04/免费领阿里云服务器/截图2.png)\n\n> + 第一次使用前，请设置root用户密码，具体操作：`更多`>`密码/密钥`>`重置示例密钥`\n> + 请确保22端口已开放，确保可以远程ssh访问。\n\n记住服务器所在公网IP地址。\n\n### 在本地windows电脑准备相应工具\n\n1. 远程终端访问工具：如putty\n\n    其实呀，windows系统的powershell、cmd都是可以用（确保本地已安装Open SSH客户端），因为事实上我们用到的是SSH访问，powershell下一行命令即可切换到远程服务器：\n   \n    ```powershell\n    ssh 远程服务器用户名@远程服务器IP地址\n    ```\n\n2. 远程文件传输工具：如WinScp\n\n   主要是如果只用黑黑的终端去访问，服务器和主机之间传输文件就太麻烦了，而且WinScp是图形化界面，易于查看\n\n### 远程访问ECS\n\n#### 终端访问\n\n此处选用Powershell！\n\n1. powershell输入命令：\n\n   ```powershell\n   ssh root@你的远程服务器IP地址\n   ```\n\n\t这就表示要以root用户连接到服务器\n\n2. 接下来会让你输入密码。\n\n   注意：输入密码时不会显示任何东西，这防止他人知道密码位数。\n\n   输入密码就可以访问了。输入你喜欢的linux命令吧\n   \n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn@0.1.1.4/post/2020/07/04/免费领阿里云服务器/截图3.png\" style=\"zoom:50%;\" />\n\n#### SFTP访问\n\n> WinScp可以和powershell访问同时进行，这样，powershell用于输入命令并发送到远程服务器，WinScp用于以GUI形式查看、管理云服务器的文件\n\n1. 打开WinScp，自动弹出登录窗口，填写主机名(即IP地址)、用户名()root)、密码、端口(22)\n\n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn@0.1.1.4/post/2020/07/04/免费领阿里云服务器/截图4.png\" style=\"zoom: 50%;\" />\n\n2. 登录成功，即可管理或者传输服务器上的文件啦\n\n## 不想每次连接时都输入密码？\n\n这个时候就要用到ssh密钥访问啦，使用ssh密钥可不输入密码远程访问云服务器！\n\n1. 创建SSH key\n\n   在Windows下查看**[c盘->用户->自己的用户名->.ssh]**下是否有`id_rsa`、`id_rsa.pub`文件，如果没有需要手动生成,有的话直接跳到第二步。\n\n   打开Git Bash，在终端中输入以下命令 \n\n   ```powershell\n   ssh-keygen -t rsa -C \"youremail@example.com\"\n   ```\n\n   输入完毕后按回车，程序会要求输入一个密码，输入完密码后按回车会要求再确认一次密码，如果不想要密码可以在要求输入密码的时候按两次回次，表示密码为空，并且确认密码为空，此时**[c盘>用户>自己的用户名>.ssh]**目录下已经生成好了。\n\n   **打开`id_rsa.pub`文件，全选复制其中的内容**\n\n2. 将生成的SSH Key添加到远程服务器\n\n   使用刚才打开的WinScp软件，进入到目录`/root/.ssh`，新建一个文件`authorized_keys`，编辑文件，将刚才复制的内容粘贴到`authorized_keys`中，保存。\n\n   或者使用powershell命令行(当前未连接ECS下)：\n\n   ```powershell\n   scp -r 'C:\\Users\\你的用户名\\.ssh\\id_rsa.pub' root@服务器IP:/root/.ssh/authorized_keys\n   ```\n\n   使用命令行时，依旧会要求输入密码。\n\n以上设置均完成后，下此使用`ssh root@服务器IP `就不用输入密码啦！","tags":["服务器","linux"],"categories":["操作","linux"]},{"title":"在Win10 PC上安装Ubuntu 20.04 系统","url":"/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/","content":"\n> 本文仅适用于UEFI+GPT类型的PC，有关这方面的知识请自行了解。\n\n## 引言\n\n### 为什么需要使用 Linux 系统？\n\n既已看到此文，我相信你一定有需求来使用linux系统了。\n\n> linux是服务器首选操作系统\n\n1. 稳定、高效\n\n   linux系统相对windows系统稳定并且高效，服务器要求长时间运行不关机，显然windows系统不适和使用在服务器上。并且Linux系统更改大多数配置都无需重启服务器即可生效，这也确保了 Linux 服务器最短的停机时间。\n\n2. 开源\n\n   linux系统是开源的，你可以对系统进行自定义，以满足使用要求，这是Windows无法比拟的。\n\n3. 性能发挥\n\n   服务器端linux可自由配置GUI界面或者仅使用“**终端**”进行管理，保证其对硬件配置需求低\n   ……\n\n<!-- more -->\n\n而作为程序员的你，如果要做在服务器上进行开发，就必须要学会使用linux！\n\n> 我认为，如果仅做开发，linux系统实在太自由、舒服了\n\n​\t在终端里演绎出自己的世界，一行一行命令即可掌控全局！\n\n​\t也不再有国内生态下windows满天飞的广告了！\n\n### 为什么选择Ubuntu？\n\n这个嘛，因为ubuntu对新手太友好了！而且，ubuntu对桌面系统支持特别好。同时，使用ubuntu的人也非常多。\n\n## 安装前准备\n\n1. 已经安装好windows10的一台PC\n\n   官方推荐配置：\n\n   - [x] 2 GHz 双核处理器或更快的处理器\n\n   - [x] 4 GB 系统内存\n\n   - [x] 25 GB 的可用硬盘空间\n\n   本文PC平台：\n\n   | 项目            | 配置                           |\n   | --------------- | ------------------------------ |\n   | 品牌型号        | Lenovo Xiaoxin Pro-13 IML 2019 |\n   | CPU             | Intel Core i7-10710U           |\n   | RAM             | 16 GB                          |\n   | SSD             | 512GB                          |\n   | GPU             | NVIDIA Geforce MX250           |\n   | 已安装Win10版本 | Windows 10 Pro 1909 18363.900  |\n\n   > 本文安装教程仅在此平台测试过，其他PC平台请自行参考\n\n2. Ubuntu 20.04 镜像文件\n\n   从Ubuntu[官网（点此进入）](https://ubuntu.com/download/desktop)下载Ubuntu 20.04 LTS 镜像文件。\n\n![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/01.png)\n\n<center> 点击download按钮下载Ubuntu 20.04 LTS 镜像文件</center>\n\n​\t\t点击下载按钮后可能会出现捐助页面，你可以根据个人情况进行捐助。\n\n​\t\t如果你觉得下载速度慢，你可以使用某些下载器（如迅雷、Motrix）进行下载。\n\n3. 一个空间大于4GB的U盘\n\n   请在安装前，确保U盘内所有内容都已备份！U盘将用于制作Ubuntu安装盘。\n\n   另外，推荐使用USB3.0以上的U盘（PC也要有USB3.0端口），安装时间更快。\n\n4. 一款USB启动盘制作软件\n\n   常见的工具软件是UltralSO，不过此处我推荐使用Rufus，使用它安装系统更为简洁、明了。并且Ubuntu官网也推荐使用Rufus进行安装。\n\n   Rufus下载地址：http://rufus.ie/\n\n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/03.png\" style=\"zoom:50%;\" />\n\n   <center>点击 Rufus 3.11 进行下载。</center>\n\n5. 查看电脑BIOS模式\n\n   使用<kbd>Win</kbd>+<kbd>R</kbd>打开运行窗口，输入“msinfo32”(不含括号)回车，出现以下界面，可查看BIOS模式：\n   \n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/02.png\" style=\"zoom:50%;\" />\n   \n   可见，本文BIOS模式为UEFI，如果你显示为“传统”字样，那么本教程可能不适用你的电脑。\n   \n   BIOS模式有传统的MBR模式和新式UEFI模式，这将对安装双系统的方法产生直接影响。目前来看，大部分电脑都属于新式UEFI模式，不过也存在一些老机子仍然属于传统MBR模式。本教程只介绍新式UEFI模式下的双系统安装方法，如果你的电脑属于传统MBR模式，强烈建议你重装windows系统来更新BIOS模式到UEFI。\n\n## STEP1 制作U盘启动安装盘\n\n1. 双击运行下载好的Rufus软件\n\n2. 插入U盘\n\n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/04.png\" style=\"zoom:50%;\" />\n\n<center>此时请确保设备下拉框选中的是你的U盘</center>\n\n3. 加载引导镜像\n\n   点击**选择**按钮，这将打开一个文件选择窗口，请选择之前下载好的Ubuntu 20.04 LTS 镜像（本教程下载后的镜像名为ubuntu-20.04-desktop-amd64.iso）\n\n4. 选择分区类型\n\n   前文已经提到，本机BIOS采用的是UEFI，所以将分区类型选择为GPT模式。\n   \n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/05.png\" style=\"zoom:50%;\" />\n\n5. 写入镜像\n\n   **在进行此操作前，请确保U盘文件已备份。**\n\n   点击开始按钮，将进行写入操作。\n\n   同时，可能会提示“检测到ISOHybrid镜像”，请选择默认选项，并点击OK。\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/06.png\" style=\"zoom:50%;\" />\n\n​\t\t之后，还会弹出警告窗口，请确保已备份U盘文件，然后点击确定，这将开始操作。\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/07.png\" style=\"zoom:50%;\" />\n\n​\t\t使用USB3.0的U盘，大约在3分钟后完成写入操作。\n\n​\t\t完成后，可以关闭软件。\n\n## STEP2 分配用于Ubuntu的空间大小\n\n1. 右键左下角windows图标，选择“磁盘管理”选项。\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/08.png\" style=\"zoom:50%;\" />\n\n2. 在PC磁盘(**非U盘**)末尾（也就是**最后一个盘**）分配一个合适大小的空间，用于Ubuntu的使用。\n\n   （如果你的PC是双硬盘，本文可能不适用）\n\n   此处建议80GB或100GB\n\n   ![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/09.png)\n\n   <center>右键最后一个盘(此处为E盘)，点击压缩卷，以压缩出Ubuntu的空间。</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/10.png\" style=\"zoom:50%;\" />\n\n<center>输入压缩空间量，<b>注意单位是MB</b>，此处我选择了80GB(即80*1024=81920MB)，然后点击压缩</center>\n\n​\t最终，盘末压缩出了80GB未分配的空间，这将用于Ubuntu。\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/11.png\" style=\"zoom:67%;\" />\n\n> 现在，准备工作已经完成了一大半，请关闭计算机，进入下一步骤\n\n## STEP3 安装前的BIOS设置\n\n进入BIOS设置界面，具体品牌有具体的方法，请自行查找。(本机为开机按F2键)\n\n以下BIOS界面所示为联想小新PRO 13 英特尔版。\n\n1. 设置UEFI固件选项\n\n   <img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/12.png\" style=\"zoom:50%;\" />\n\n   <center>开机按F2键，进入BIOS设置界面，点击<b>Boot Setup</b></center>\n\n   ![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/13.jpg)\n   \n   <center>切换到<b>Security</b>选项卡，将<b>Secure Boot</b>值改为<b>Disabled</b>。</center>\n   \n   > 此步骤旨在关闭安全启动。有关安装Linux系统和关闭安全启动的原因请自行了解。\n\n2. 退出BIOS设置界面，**保存设置**，并关机\n\n## STEP4 安装Ubuntu 20.02 LTS\n\n### 1. 插入U盘，进入U盘启动界面\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/14.jpg\" style=\"zoom:50%;\" />\n\n<center>开机按F2键，进入启动项选择界面，点击<b>Boot Menu</b></center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/15.jpg\" style=\"zoom: 67%;\" />\n\n<center>选择U盘启动项，例如这里：Linpus lite</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/16.jpg\" style=\"zoom: 25%;\" />\n\n<center>在左上角，选择Ubuntu项，回车</center>\n\n​\t等待数秒后，即可开始安装\n\n### 2. 开始安装\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/17.jpg\" style=\"zoom: 33%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/18.jpg\" style=\"zoom:33%;\" />\n\n<center>根据需要选择语言、键盘布局</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/19.jpg\" style=\"zoom:33%;\" />\n\n<center>根据需要选择安装</center>\n\n### 3. 为Ubuntu进行合理系统分区\n\n![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/20.jpg)\n\n<center><b>安装类型务请必选择其他选项</b>，否则Windows系统可能将不复存在</center>\n\n![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/21.jpg)\n\n**接下来，将进行分区操作，请谨慎小心，一旦出错，后果可能出乎意料！**\n\n有关linux系统的目录结构与windows的区别，请自行了解相关知识。\n\n为ubuntu分区有很多种方式，这里只介绍我操作的。\n\n我的分区方案是：\n\n| 挂载点 | 分区用于         | 分区类型 | 分区位置     | 大小                         |\n| ------ | ---------------- | -------- | ------------ | ---------------------------- |\n|        | EFI系统分区      | 逻辑分区 | 空间起始位置 | 128MB - 512MB，推荐直接512MB |\n|        | Swap交换空间     | 逻辑分区 | 空间起始位置 | 视具体情况而定，见下文       |\n| /      | Ext4日志文件系统 | 主分区   | 空间起始位置 | 可分配空间的30%              |\n| /home  | Ext4日志文件系统 | 逻辑分区 | 空间起始位置 | 剩余未分配空间               |\n\n---\n\n下面开始具体操作(每次操作都对上图所示**橙色的空闲未分配区域**）：\n\n请一定按照顺序进行。\n\n#### 1. EFI系统分区\n\n> EFI，全称“Extensible Firmware Interface”，即可扩展固件接口，用于操作系统启动前，完成硬件初始化，并引导进入操作系统。现在，绝大多数个人PC都使用EFI升级版本——UEFI。\n>\n> 点击左下角“+”号，弹出创建分区界面\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/22.jpg\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/23.jpg\" style=\"zoom:50%;\" />\n\n将大小改为**512MB**(推荐值)，分区类型改为**逻辑分区**，分区位置设置为**空间起始位置**，用于选择**EFI系统分区**。\n\n![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/24.jpg)\n\n点击OK后，**请记下此时创建好的efi分区所在的设备号**，如本次安装在/dev/nvme0n1p7 (不是windows所在的efi分区，请看清楚)\n\n#### 2. Swap交换分区\n\n> Swap分区在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。通俗来讲，Swap空间相当于Windows中的虚拟内存。\n\n分配Swap分区大小视情况而定：\n\n| RAM 物理内存 | 推荐 Swap 分区大小 | 需要休眠功能下建议的交换空间大小 |\n| :----------: | :----------------: | :------------------------------: |\n|    ≤ 2GB     |    2倍于RAM大小    |           3倍于RAM大小           |\n|    > 2GB     |     和RAM相同      |           2倍于RAM大小           |\n| > 8GB - 64GB |      至少4GB       |          1.5倍于RAM大小          |\n|    > 64GB    |      至少4GB       |            不建议休眠            |\n\n对本机(机带RAM 16GB)以及分配给Ubuntu的大小(80GB)，综合考虑，Swap分区设置为8GB(8192MB)。\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/25.jpg\" style=\"zoom: 25%;\" />\n\n#### 3. 根目录 (/)\n\n> linux的文件系统是采用级层式的树状目录结构，在此结构中最上层是根目录“/”，然后在此目录下再创建其它的目录。\n>\n> 在linux世界里，一切接文件\n>\n> 下图可清晰理解:\n>\n> ![mermaid](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/mermaid.png)\n\n根目录设置为可分配空间(此处为80GB)的30%，即大约25GB(25600MB)。\n\n#### 4. 家目录 (/home)\n\n> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示\n\n应此分区存放内容较多，应将其设置尽可能大，而之前已经分配完该分配的空间了，这里只需将剩余的空间全部给 /home 分区即可，这就是为什么 /home 分区放在最后设置。\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/26.jpg\" style=\"zoom: 67%;\" />\n\n### 4. 执行安装\n\n**注意：分区结束后请勿立即开始安装！**\n\n![](https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/27.png)\n\n<center><b>请确保安装启动引导器的设备为设置EFI系统分区时的设备号！</b>(/dev/nvme0n1p7)</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/28.jpg\" style=\"zoom: 67%;\" />\n\n<center>现在，一切就绪，点击<kbd>现在安装(I)</kbd>，如遇提示，请点击<kbd>继续</kbd>后，执行安装</center>\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/29.jpg\" style=\"zoom: 50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/30.jpg\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/31.jpg\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/32.jpg\" style=\"zoom:50%;\" />\n\n<center>执行系列操作后，重新启动PC</center>\n\n## STEP5 进入Ubuntu系统\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/33.jpg\" style=\"zoom: 25%;\" />\n\n<center>重启后，提示移除安装介质，请将U盘拔出后，键入回车</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/34.jpg\" style=\"zoom: 50%;\" />\n\n<center>若没有手动选择启动项，几秒钟后将自动进入Ubuntu</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/27/在Win10-PC上安装Ubuntu-20-04-系统/35.jpg\" style=\"zoom: 50%;\" />\n\n<center><b>现在，你可以开始体验Ubuntu 20.04了！</b></center>\n\n\n\n> 感谢你阅读到此，希望本文对你有所帮助，如有问题，请在主页里用邮件方式联系我！\n","tags":["linux","软件安装","Ubuntu","操作系统"],"categories":["操作","linux"]},{"title":"冒泡排序","url":"/2020/06/26/冒泡排序/","content":"\n## 要求\n\n输入n个整数，将它们从小到大排序后输出，要求使用冒泡排序算法。\n\n<!-- more -->\n\n## 算法分析\n\n对于搜索大型数据库来说，对数据进行排序的算法是至关重要的。用词典来查找字词是相对容易和方便的，这是因为词典按字母表顺序排了序。排序（sort）是一种非常有助于解决查找问题的技术，此外，如何有效的排序本身就是计算机算法的一个重要研究领域。\n之所以叫做冒泡排序，是因为在进行从小到大排序时，小的数经过交换会慢慢从底下“冒”上来。冒泡排序效率不高，这是因为他需要约$\\frac{n^2}{2}$次比较。然而对一些小数组来说，它的性能通常还是可以接受的。对于数组a，假定输入后值为{7, 3, 66, 3, -5, 22, -77, 2}，再调用bubble(a,8)。下表给出了在每次外部循环后数组a中的元素。\n\n|              | a[0] | a[1]   | a[2]  | a[3]  | a[4]  | a[5]  | a[6]   | a[7]   |\n| ------------ | ---- | ------ | ----- | ----- | ----- | ----- | ------ | ------ |\n| 未排序的数据 | 7    | 3      | 66    | 3     | -5    | 22    | -77    | 2      |\n| 第1遍        | 3    | 7      | 3     | -5    | 22    | -77   | 2      | **66** |\n| 第2遍        | 3    | 3      | -5    | 7     | -77   | 2     | **22** | **66** |\n| 第3遍        | 3    | -5     | 3     | -77   | 2     | **7** | **22** | **66** |\n| 第4遍        | -5   | 3      | -77   | 2     | **3** | **7** | **22** | **66** |\n| 第5遍        | -5   | -77    | 2     | **3** | **3** | **7** | **22** | **66** |\n| 第6遍        | -77  | -5     | **2** | **3** | **3** | **7** | **22** | **66** |\n| 第7遍        | -77  | **-5** | **2** | **3** | **3** | **7** | **22** | **66** |\n\n在第一次循环的开始处，把a[0]与a[1]比较，由于它们不符合次序要求，对它们要做交换；然后把a[1]与a[2]比较，由于它们符合次序要求，对他们不做交换；再把a[2]与a[3]比较，依此类推。若邻接元素不符合次序要求，则要求对它们进行交换。第一次循环的效果是把数组中的最大元素“冒泡”到a[7]。在第二次循环后，不再检查a[7]，即不再改变它，把a[0]再与a[1]比较，如此等等。在第二次循环后，第二大的数存放在a[6]中。由于每次循环都把当前最大的元素放在数组的合适位置，在n-1次循环后，算法就完成了所有元素的排序。\n\n> 排序是程序算法中非常有挑战意义的，这里给出的冒泡排序和[选择排序法](https://www.xxdiandeng.cn/2020/06/25/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/)从效率上讲都不是很高，实际需要的排序时间也很长，特别是在数据量很大的情况下更是耗费时间。请读者改进冒泡排序算法，以提高算法的效率，这也有助于进一步理解程序设计算法以及指针和数组的使用。\n\n\n\n<p align=\"right\">摘自高等教育出版社《C语言程序设计（第3版）》（何钦铭，颜晖主编）</p>\n\n## 示例源代码\n\n```c\n /*冒泡排序算法*/\n #include <stdio.h>\n void bubble(int a[], int n);\n \n int main()\n {\n     int n, a[8];\n     int i;\n \n     printf(\"Enter n (n<=8) :\");\n     scanf(\"%d\", &n);\n     printf(\"Enter a[%d]:\", n);\n     for (i = 0; i < n; i++)\n         scanf(\"%d\", &a[i]);\n     bubble(a, n);\n     printf(\"After sorted, a[%d] = \", n);\n     for (i = 0; i < n; i++)\n         printf(\"%3d\", a[i]);\n     return 0;\n }\n \n void bubble(int a[], int n)         //n是数组a中待排序元素的数量\n {\n     int i, j, t;\n     for (i = 1; i < n; i++)         //外部循环\n         for (j = 0; j < n - 1; j++) //内部循环\n             if (a[j] > a[j + 1])    //比较两个元素的大小\n             {\n                 //如果前一个元素大，则交换\n                 t = a[j];\n                 a[j] = a[j + 1];\n                 a[j + 1] = t;\n             }\n }\n```\n\n### 运行结果\n\n> Enter n (n<=8) :8\n>\n> Enter a[8]:7 3 66 3 -5 22 -77 2\n>\n> After sorted, a[8] = -77 -5 2 3 3 7 22 66","tags":["C语言","算法"],"categories":["数据结构与算法","排序"]},{"title":"选择排序","url":"/2020/06/25/选择排序/","content":"\n## 要求\n\n输入一个正整数n（1<n≤10），再输入n个整数，用选择排序法将它们从小到大排序后输出。\n\n<!-- more -->\n\n## 算法步骤\n* 第一步：在未排序的 n 个数（a[0] ~ a[n - 1]）中找到最小数，将它与 a[0] 交换；\n* 第二步：在剩下未排序的 n - 1 个数（a[1] ~ a[n - 1]）中找到最小数，将它与 a[1] 交换；\n* ……\n* 第 n - 1 步：在剩下未排序的2个数（a[n - 2] ~ a[n - 1]）中找到最小数，将它与 a[1] 交换；\n\n## 算法流程图\n<img src=\"https://cdn.jsdelivr.net/gh/DianDengJun/cdn/post/2020/06/25/选择排序/选择排序.jpg\" style=\"zoom: 33%;\" />\n\n## 示例源代码\n```c\n/* 选择法排序 */\n#include <stdio.h>\nint main()\n{\n\tint i, index, k, n, temp;\n\tint a[10];\t\t\t//\t定义1个数组a，它有10个整型元素\n\tprintf(\"Enter n:\"); //\t提示输入n\n\tscanf(\"%d\", &n);\n\tprintf(\"Enter %d integers:\", n); //\t提示输入n个数\n\tfor (i = 0; i < n; i++)\t\t\t //\t将输入数一次赋给数组a的n个元素a[0]~a[n-1]\n\t\tscanf(\"%d\", &a[i]);\n\t/* 对n个数排序 */\n\tfor (k = 0; k < n - 1; k++)\n\t{\n\t\tindex = k;\t\t\t\t\t//\tindex存放最小值所在的下标\n\t\tfor (i = k + 1; i < n; i++) //\t寻找最小值所在的下标\n\t\t\tif (a[i] < a[index])\n\t\t\t\tindex = i;\n\t\ttemp = a[index]; //\t最小元素与下标k的元素交换\n\t\ta[index] = a[k];\n\t\ta[k] = temp;\n\t}\n\n\tprintf(\"After sorted:\");\n\tfor (i = 0; i < n; i++)\n\t\tprintf(\"%d\", a[i]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n```\n\n### 运行结果\n\n> Enter n:<u>5</u>\n>\n> Enter 5 integers:<u>3 5 2 8 1</u>\n>\n> After sorted:1 2 3 5 8\n\n\n\n<p align=\"right\">摘自高等教育出版社《C语言程序设计（第3版）》（何钦铭，颜晖主编）</p>\n","tags":["C语言","算法"],"categories":["数据结构与算法","排序"]}]